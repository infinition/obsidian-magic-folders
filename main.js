/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MagicFoldersPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var DEFAULT_SETTINGS = {
  magicFolders: [],
  showInExplorer: true,
  refreshOnChange: true,
  showTooltips: true,
  cache: [],
  language: "fr",
  customIconsEnabled: false,
  customIconFolder: "",
  showNewItemsBadge: true,
  highlightUnreadFiles: true,
  showFileCount: true
};
var AVAILABLE_ICONS = [
  "folder-search",
  "wand-2",
  "sparkles",
  "star",
  "heart",
  "bookmark",
  "tag",
  "hash",
  "filter",
  "layers",
  "box",
  "archive",
  "briefcase",
  "folder-heart",
  "folder-key",
  "folder-check",
  "folder-clock",
  "zap",
  "flame",
  "target",
  "trophy",
  "crown",
  "gem",
  "rocket",
  "lightbulb",
  "brain",
  "puzzle",
  "compass",
  "map",
  "globe"
];
var PRESET_COLORS = [
  "#e74c3c",
  "#e67e22",
  "#f1c40f",
  "#2ecc71",
  "#1abc9c",
  "#3498db",
  "#9b59b6",
  "#e91e63",
  "#00bcd4",
  "#607d8b",
  "#795548",
  "#ff5722",
  "#8bc34a",
  "#673ab7",
  "#ff9800"
];
var TRANSLATIONS = {
  en: {
    settings_title: "Magic Folders \u2013 Settings",
    settings_show_tooltips_name: "Show tooltips",
    settings_show_tooltips_desc: "Show tags and matched filters on hover in magic folders.",
    settings_language_name: "Language",
    settings_language_desc: "Choose the plugin language.",
    settings_custom_icons_name: "Use custom icons",
    settings_custom_icons_desc: "Enable icons from a vault folder.",
    settings_custom_icons_path_name: "Custom icon folder",
    settings_custom_icons_path_desc: "Vault or external folder path containing icons (svg/png/jpg).",
    settings_show_new_badge_name: "Show new items badge",
    settings_show_new_badge_desc: "Show a badge on collapsed magic folders when new items appear.",
    settings_unread_highlight_name: "Highlight unread files",
    settings_unread_highlight_desc: "Bold and highlight new files until they are opened.",
    settings_show_file_count_name: "Show file count",
    settings_show_file_count_desc: "Show the number of matched files next to the folder name.",
    settings_refresh_on_change_name: "Auto refresh",
    settings_refresh_on_change_desc: "Refresh magic folders when files change.",
    menu_create_here: "Create Magic Folder here",
    menu_in_magic_folder: "In Magic Folder: {name}",
    menu_matched: "Matched: {filters}",
    menu_open: "Open",
    menu_open_source: "Open in source folder",
    menu_open_new_tab: "Open in new tab",
    menu_do_magic: "Do Magic (Edit Filters)",
    menu_edit: "Edit Magic Folder",
    menu_move_up: "Move Up",
    menu_move_down: "Move Down",
    menu_sort_name: "Sort by: Name",
    menu_sort_modified: "Sort by: Last modified",
    menu_sort_created: "Sort by: Created Date",
    menu_sort_type: "Sort by: File type",
    menu_sort_size: "Sort by: File Size",
    menu_sort_tag: "Sort by: Tag",
    menu_order_asc: "Order: Ascending",
    menu_order_desc: "Order: Descending",
    menu_refresh: "Refresh",
    menu_delete: "Delete Magic Folder",
    menu_mark_read: "Mark as Read",
    menu_mark_unread: "Mark as Unread",
    menu_mark_all_read: "Mark all as Read",
    menu_mark_all_unread: "Mark all as Unread",
    command_create: "Create Magic Folder",
    command_create_here: "Create Magic Folder in current folder",
    command_refresh: "Refresh all Magic Folders",
    notice_created: 'Magic Folder "{name}" created!',
    notice_updated: 'Magic Folder "{name}" updated!',
    notice_deleted: 'Magic Folder "{name}" deleted!',
    notice_refresh: "{name} refreshed!",
    notice_name_required: "Please enter a name for your magic folder",
    notice_marked_all_read: 'All files in "{name}" marked as read.',
    notice_marked_all_unread: 'All files in "{name}" marked as unread.',
    modal_create_title: "Create Magic Folder",
    modal_edit_title: "Edit Magic Folder",
    modal_name_label: "Name",
    modal_name_desc: "The name of your magic folder",
    modal_name_placeholder: "My Magic Folder",
    modal_default_name: "New Magic Folder",
    modal_color_label: "Color",
    modal_color_desc: "Choose a color for your magic folder",
    modal_icon_label: "Icon",
    modal_icon_desc: "Choose an icon for your magic folder",
    modal_emoji_label: "Emoji (optional)",
    modal_emoji_desc: "Choose an emoji for your magic folder",
    modal_emoji_search: "Search emoji...",
    modal_custom_icons_label: "Custom icons",
    modal_sort_by_label: "Sort by",
    modal_sort_by_desc: "How to sort files in this folder",
    modal_sort_name: "Name (A-Z)",
    modal_sort_modified: "Last Modified",
    modal_sort_created: "Created Date",
    modal_sort_type: "File Type",
    modal_sort_size: "File Size",
    modal_sort_tag: "Tag",
    modal_sort_asc: "\u2191 Ascending",
    modal_sort_desc: "\u2193 Descending",
    modal_cancel: "Cancel",
    modal_create: "Create Magic Folder",
    modal_save: "Save Changes",
    do_magic_title: "Do Magic",
    do_magic_help: "Use #tags, [[links]], .ext, folder:, ext:, or key:value.",
    do_magic_help_tags: "Tags: #project or #parent/child",
    do_magic_help_links: "Links: [[Note Name]]",
    do_magic_help_folder: "Folder filter: folder:Folder/Sub",
    do_magic_help_ext: "Extension: .pdf or ext:pdf",
    do_magic_help_frontmatter: "Frontmatter: key:value",
    do_magic_help_multi: "Multiple tokens separated by spaces",
    do_magic_help_logic: "Use OR / AND / NOT buttons above to combine",
    do_magic_logic_label: "Add as: ",
    do_magic_input_placeholder: "Type # for tags, [[ for links, . for extensions...",
    do_magic_add: "Add",
    do_magic_preview: "Preview",
    do_magic_preview_empty: "Add filters to see matching files",
    do_magic_preview_none: "No files match your filters",
    do_magic_preview_count: "<strong>{count}</strong> files will appear in this magic folder:",
    do_magic_apply: "Apply Magic \u2728"
  },
  fr: {
    settings_title: "Magic Folders \u2013 Param\xE8tres",
    settings_show_tooltips_name: "Afficher les tooltips",
    settings_show_tooltips_desc: "Afficher les tags et filtres match\xE9s au survol des fichiers.",
    settings_language_name: "Langue",
    settings_language_desc: "Choisir la langue du plugin.",
    settings_custom_icons_name: "Utiliser des ic\xF4nes personnalis\xE9es",
    settings_custom_icons_desc: "Activer des ic\xF4nes depuis un dossier du coffre.",
    settings_custom_icons_path_name: "Dossier d\u2019ic\xF4nes",
    settings_custom_icons_path_desc: "Chemin du dossier (coffre ou externe) contenant des ic\xF4nes (svg/png/jpg).",
    settings_show_new_badge_name: "Badge nouveaux \xE9l\xE9ments",
    settings_show_new_badge_desc: "Afficher un badge sur les dossiers repli\xE9s quand il y a du nouveau.",
    settings_unread_highlight_name: "Mettre en \xE9vidence les fichiers non lus",
    settings_unread_highlight_desc: "Met en gras les nouveaux fichiers jusqu\u2019\xE0 leur ouverture.",
    settings_show_file_count_name: "Afficher le nombre de fichiers",
    settings_show_file_count_desc: "Afficher le compteur de fichiers \xE0 c\xF4t\xE9 du nom du dossier.",
    settings_refresh_on_change_name: "Actualisation auto",
    settings_refresh_on_change_desc: "Rafra\xEEchir les dossiers quand les fichiers changent.",
    menu_create_here: "Cr\xE9er un Magic Folder ici",
    menu_in_magic_folder: "Dans Magic Folder : {name}",
    menu_matched: "Matched : {filters}",
    menu_open: "Ouvrir",
    menu_open_source: "Ouvrir dans le dossier source",
    menu_open_new_tab: "Ouvrir dans un nouvel onglet",
    menu_do_magic: "Do Magic (\xE9diter les filtres)",
    menu_edit: "\xC9diter le Magic Folder",
    menu_move_up: "Monter",
    menu_move_down: "Descendre",
    menu_sort_name: "Trier par : Nom",
    menu_sort_modified: "Trier par : Modifi\xE9",
    menu_sort_created: "Trier par : Date de cr\xE9ation",
    menu_sort_type: "Trier par : Type de fichier",
    menu_sort_size: "Trier par : Taille",
    menu_sort_tag: "Trier par : Tag",
    menu_order_asc: "Ordre : Croissant",
    menu_order_desc: "Ordre : D\xE9croissant",
    menu_refresh: "Rafra\xEEchir",
    menu_delete: "Supprimer le Magic Folder",
    menu_mark_read: "Marquer comme lu",
    menu_mark_unread: "Marquer comme non lu",
    menu_mark_all_read: "Tout marquer comme lu",
    menu_mark_all_unread: "Tout marquer comme non lu",
    command_create: "Cr\xE9er un Magic Folder",
    command_create_here: "Cr\xE9er un Magic Folder dans le dossier courant",
    command_refresh: "Rafra\xEEchir tous les Magic Folders",
    notice_created: 'Magic Folder "{name}" cr\xE9\xE9 !',
    notice_updated: 'Magic Folder "{name}" mis \xE0 jour !',
    notice_deleted: 'Magic Folder "{name}" supprim\xE9 !',
    notice_refresh: "{name} rafra\xEEchi !",
    notice_name_required: "Veuillez saisir un nom pour votre Magic Folder",
    notice_marked_all_read: 'Tous les fichiers de "{name}" marqu\xE9s comme lus.',
    notice_marked_all_unread: 'Tous les fichiers de "{name}" marqu\xE9s comme non lus.',
    modal_create_title: "Cr\xE9er un Magic Folder",
    modal_edit_title: "\xC9diter un Magic Folder",
    modal_name_label: "Nom",
    modal_name_desc: "Le nom de votre Magic Folder",
    modal_name_placeholder: "Mon Magic Folder",
    modal_default_name: "Nouveau Magic Folder",
    modal_color_label: "Couleur",
    modal_color_desc: "Choisissez une couleur pour votre Magic Folder",
    modal_icon_label: "Ic\xF4ne",
    modal_icon_desc: "Choisissez une ic\xF4ne pour votre Magic Folder",
    modal_emoji_label: "Emoji (optionnel)",
    modal_emoji_desc: "Choisissez un emoji pour votre Magic Folder",
    modal_emoji_search: "Rechercher un emoji...",
    modal_custom_icons_label: "Ic\xF4nes personnalis\xE9es",
    modal_sort_by_label: "Trier par",
    modal_sort_by_desc: "Comment trier les fichiers dans ce dossier",
    modal_sort_name: "Nom (A-Z)",
    modal_sort_modified: "Derni\xE8re modification",
    modal_sort_created: "Date de cr\xE9ation",
    modal_sort_type: "Type de fichier",
    modal_sort_size: "Taille du fichier",
    modal_sort_tag: "Tag",
    modal_sort_asc: "\u2191 Croissant",
    modal_sort_desc: "\u2193 D\xE9croissant",
    modal_cancel: "Annuler",
    modal_create: "Cr\xE9er le Magic Folder",
    modal_save: "Enregistrer",
    do_magic_title: "Do Magic",
    do_magic_help: "Utilise #tags, [[liens]], .ext, folder:, ext:, ou key:value.",
    do_magic_help_tags: "Tags : #projet ou #parent/enfant",
    do_magic_help_links: "Liens : [[Nom de note]]",
    do_magic_help_folder: "Dossier : folder:Dossier/Sous",
    do_magic_help_ext: "Extension : .pdf ou ext:pdf",
    do_magic_help_frontmatter: "Frontmatter : cl\xE9:valeur",
    do_magic_help_multi: "Plusieurs \xE9l\xE9ments s\xE9par\xE9s par des espaces",
    do_magic_help_logic: "Utilise OR / AND / NOT pour combiner",
    do_magic_logic_label: "Ajouter comme : ",
    do_magic_input_placeholder: "Tapez # pour tags, [[ pour liens, . pour extensions...",
    do_magic_add: "Ajouter",
    do_magic_preview: "Aper\xE7u",
    do_magic_preview_empty: "Ajoutez des filtres pour voir les fichiers",
    do_magic_preview_none: "Aucun fichier ne correspond",
    do_magic_preview_count: "{count} fichiers appara\xEEtront dans ce Magic Folder :",
    do_magic_apply: "Appliquer la magie \u2728"
  },
  es: {
    settings_title: "Magic Folders \u2013 Ajustes",
    settings_show_tooltips_name: "Mostrar tooltips",
    settings_show_tooltips_desc: "Mostrar etiquetas y filtros al pasar el mouse.",
    settings_language_name: "Idioma",
    settings_language_desc: "Elegir el idioma del plugin.",
    settings_custom_icons_name: "Usar iconos personalizados",
    settings_custom_icons_desc: "Activar iconos desde una carpeta del vault.",
    settings_custom_icons_path_name: "Carpeta de iconos",
    settings_custom_icons_path_desc: "Ruta de carpeta (b\xF3veda o externa) con iconos (svg/png/jpg).",
    settings_show_new_badge_name: "Badge de nuevos elementos",
    settings_show_new_badge_desc: "Mostrar badge en carpetas colapsadas con nuevos elementos.",
    settings_unread_highlight_name: "Resaltar archivos no le\xEDdos",
    settings_unread_highlight_desc: "Pone en negrita los nuevos archivos hasta que se abran.",
    settings_show_file_count_name: "Mostrar conteo de archivos",
    settings_show_file_count_desc: "Muestra el n\xFAmero de archivos junto al nombre de la carpeta.",
    settings_refresh_on_change_name: "Actualizaci\xF3n autom\xE1tica",
    settings_refresh_on_change_desc: "Actualizar cuando cambien los archivos.",
    menu_create_here: "Crear Magic Folder aqu\xED",
    menu_in_magic_folder: "En Magic Folder: {name}",
    menu_matched: "Coincide: {filters}",
    menu_open: "Abrir",
    menu_open_source: "Abrir en carpeta de origen",
    menu_open_new_tab: "Abrir en nueva pesta\xF1a",
    menu_do_magic: "Do Magic (editar filtros)",
    menu_edit: "Editar Magic Folder",
    menu_move_up: "Mover arriba",
    menu_move_down: "Mover abajo",
    menu_sort_name: "Ordenar por: Nombre",
    menu_sort_modified: "Ordenar por: Modificado",
    menu_sort_created: "Ordenar por: Fecha de creaci\xF3n",
    menu_sort_type: "Ordenar por: Tipo de archivo",
    menu_sort_size: "Ordenar por: Tama\xF1o",
    menu_sort_tag: "Ordenar por: Etiqueta",
    menu_order_asc: "Orden: Ascendente",
    menu_order_desc: "Orden: Descendente",
    menu_refresh: "Actualizar",
    menu_delete: "Eliminar Magic Folder",
    menu_mark_read: "Marcar como leido",
    menu_mark_unread: "Marcar como no leido",
    menu_mark_all_read: "Marcar todo como le\xEDdo",
    menu_mark_all_unread: "Marcar todo como no le\xEDdo",
    command_create: "Crear Magic Folder",
    command_create_here: "Crear Magic Folder en la carpeta actual",
    command_refresh: "Actualizar todos los Magic Folders",
    notice_created: 'Magic Folder "{name}" creado!',
    notice_updated: 'Magic Folder "{name}" actualizado!',
    notice_deleted: 'Magic Folder "{name}" eliminado!',
    notice_refresh: "{name} actualizado!",
    notice_name_required: "Introduce un nombre para tu Magic Folder",
    notice_marked_all_read: 'Todos los archivos en "{name}" marcados como le\xEDdos.',
    notice_marked_all_unread: 'Todos los archivos en "{name}" marcados como no le\xEDdos.',
    modal_create_title: "Crear Magic Folder",
    modal_edit_title: "Editar Magic Folder",
    modal_name_label: "Nombre",
    modal_name_desc: "El nombre de tu Magic Folder",
    modal_name_placeholder: "Mi Magic Folder",
    modal_default_name: "Nuevo Magic Folder",
    modal_color_label: "Color",
    modal_color_desc: "Elige un color para tu Magic Folder",
    modal_icon_label: "Icono",
    modal_icon_desc: "Elige un icono para tu Magic Folder",
    modal_emoji_label: "Emoji (opcional)",
    modal_emoji_desc: "Elige un emoji para tu Magic Folder",
    modal_emoji_search: "Buscar emoji...",
    modal_custom_icons_label: "Iconos personalizados",
    modal_sort_by_label: "Ordenar por",
    modal_sort_by_desc: "C\xF3mo ordenar los archivos en este folder",
    modal_sort_name: "Nombre (A-Z)",
    modal_sort_modified: "\xDAltima modificaci\xF3n",
    modal_sort_created: "Fecha de creaci\xF3n",
    modal_sort_type: "Tipo de archivo",
    modal_sort_size: "Tama\xF1o de archivo",
    modal_sort_tag: "Etiqueta",
    modal_sort_asc: "\u2191 Ascendente",
    modal_sort_desc: "\u2193 Descendente",
    modal_cancel: "Cancelar",
    modal_create: "Crear Magic Folder",
    modal_save: "Guardar cambios",
    do_magic_title: "Do Magic",
    do_magic_help: "Usa #tags, [[links]], .ext, folder:, ext:, o key:value.",
    do_magic_help_tags: "Etiquetas: #proyecto o #padre/hijo",
    do_magic_help_links: "Enlaces: [[Nombre de nota]]",
    do_magic_help_folder: "Carpeta: folder:Carpeta/Sub",
    do_magic_help_ext: "Extensi\xF3n: .pdf o ext:pdf",
    do_magic_help_frontmatter: "Frontmatter: clave:valor",
    do_magic_help_multi: "Varios tokens separados por espacios",
    do_magic_help_logic: "Usa OR / AND / NOT para combinar",
    do_magic_logic_label: "Agregar como: ",
    do_magic_input_placeholder: "Escribe # para tags, [[ para links, . para extensiones...",
    do_magic_add: "Agregar",
    do_magic_preview: "Vista previa",
    do_magic_preview_empty: "A\xF1ade filtros para ver coincidencias",
    do_magic_preview_none: "Ning\xFAn archivo coincide",
    do_magic_preview_count: "{count} archivos aparecer\xE1n en este Magic Folder:",
    do_magic_apply: "Aplicar magia \u2728"
  },
  de: {
    settings_title: "Magic Folders \u2013 Einstellungen",
    settings_show_tooltips_name: "Tooltips anzeigen",
    settings_show_tooltips_desc: "Tags und passende Filter beim Hover anzeigen.",
    settings_language_name: "Sprache",
    settings_language_desc: "Plugin-Sprache ausw\xE4hlen.",
    settings_custom_icons_name: "Benutzerdefinierte Icons",
    settings_custom_icons_desc: "Icons aus einem Vault-Ordner aktivieren.",
    settings_custom_icons_path_name: "Icon-Ordner",
    settings_custom_icons_path_desc: "Pfad zum Ordner (Vault oder extern) mit Icons (svg/png/jpg).",
    settings_show_new_badge_name: "Badge f\xFCr neue Elemente",
    settings_show_new_badge_desc: "Badge bei eingeklappten Ordnern mit neuen Elementen anzeigen.",
    settings_unread_highlight_name: "Ungelesene Dateien hervorheben",
    settings_unread_highlight_desc: "Neue Dateien fett anzeigen bis sie ge\xF6ffnet werden.",
    settings_show_file_count_name: "Dateianzahl anzeigen",
    settings_show_file_count_desc: "Anzahl der Dateien neben dem Ordnernamen anzeigen.",
    settings_refresh_on_change_name: "Auto-Aktualisierung",
    settings_refresh_on_change_desc: "Aktualisieren, wenn Dateien sich \xE4ndern.",
    menu_create_here: "Magic Folder hier erstellen",
    menu_in_magic_folder: "In Magic Folder: {name}",
    menu_matched: "Treffer: {filters}",
    menu_open: "\xD6ffnen",
    menu_open_source: "Im Quellordner oeffnen",
    menu_open_new_tab: "In neuem Tab \xF6ffnen",
    menu_do_magic: "Do Magic (Filter bearbeiten)",
    menu_edit: "Magic Folder bearbeiten",
    menu_move_up: "Nach oben",
    menu_move_down: "Nach unten",
    menu_sort_name: "Sortieren nach: Name",
    menu_sort_modified: "Sortieren nach: Ge\xE4ndert",
    menu_sort_created: "Sortieren nach: Erstellungsdatum",
    menu_sort_type: "Sortieren nach: Dateityp",
    menu_sort_size: "Sortieren nach: Gr\xF6\xDFe",
    menu_sort_tag: "Sortieren nach: Tag",
    menu_order_asc: "Reihenfolge: Aufsteigend",
    menu_order_desc: "Reihenfolge: Absteigend",
    menu_refresh: "Aktualisieren",
    menu_delete: "Magic Folder l\xF6schen",
    menu_mark_read: "Als gelesen markieren",
    menu_mark_unread: "Als ungelesen markieren",
    menu_mark_all_read: "Alle als gelesen markieren",
    menu_mark_all_unread: "Alle als ungelesen markieren",
    command_create: "Magic Folder erstellen",
    command_create_here: "Magic Folder im aktuellen Ordner erstellen",
    command_refresh: "Alle Magic Folders aktualisieren",
    notice_created: 'Magic Folder "{name}" erstellt!',
    notice_updated: 'Magic Folder "{name}" aktualisiert!',
    notice_deleted: 'Magic Folder "{name}" gel\xF6scht!',
    notice_refresh: "{name} aktualisiert!",
    notice_name_required: "Bitte einen Namen f\xFCr deinen Magic Folder eingeben",
    notice_marked_all_read: 'Alle Dateien in "{name}" als gelesen markiert.',
    notice_marked_all_unread: 'Alle Dateien in "{name}" als ungelesen markiert.',
    modal_create_title: "Magic Folder erstellen",
    modal_edit_title: "Magic Folder bearbeiten",
    modal_name_label: "Name",
    modal_name_desc: "Der Name deines Magic Folders",
    modal_name_placeholder: "Mein Magic Folder",
    modal_default_name: "Neuer Magic Folder",
    modal_color_label: "Farbe",
    modal_color_desc: "W\xE4hle eine Farbe f\xFCr deinen Magic Folder",
    modal_icon_label: "Icon",
    modal_icon_desc: "W\xE4hle ein Icon f\xFCr deinen Magic Folder",
    modal_emoji_label: "Emoji (optional)",
    modal_emoji_desc: "W\xE4hle ein Emoji f\xFCr deinen Magic Folder",
    modal_emoji_search: "Emoji suchen...",
    modal_custom_icons_label: "Benutzerdefinierte Icons",
    modal_sort_by_label: "Sortieren nach",
    modal_sort_by_desc: "Wie Dateien in diesem Ordner sortiert werden",
    modal_sort_name: "Name (A-Z)",
    modal_sort_modified: "Zuletzt ge\xE4ndert",
    modal_sort_created: "Erstellungsdatum",
    modal_sort_type: "Dateityp",
    modal_sort_size: "Dateigr\xF6\xDFe",
    modal_sort_tag: "Tag",
    modal_sort_asc: "\u2191 Aufsteigend",
    modal_sort_desc: "\u2193 Absteigend",
    modal_cancel: "Abbrechen",
    modal_create: "Magic Folder erstellen",
    modal_save: "\xC4nderungen speichern",
    do_magic_title: "Do Magic",
    do_magic_help: "Nutze #tags, [[links]], .ext, folder:, ext:, oder key:value.",
    do_magic_help_tags: "Tags: #projekt oder #parent/child",
    do_magic_help_links: "Links: [[Notizname]]",
    do_magic_help_folder: "Ordner: folder:Ordner/Unter",
    do_magic_help_ext: "Erweiterung: .pdf oder ext:pdf",
    do_magic_help_frontmatter: "Frontmatter: schluessel:wert",
    do_magic_help_multi: "Mehrere Tokens durch Leerzeichen getrennt",
    do_magic_help_logic: "OR / AND / NOT zum Kombinieren",
    do_magic_logic_label: "Hinzuf\xFCgen als: ",
    do_magic_input_placeholder: "Tippe # f\xFCr Tags, [[ f\xFCr Links, . f\xFCr Endungen...",
    do_magic_add: "Hinzuf\xFCgen",
    do_magic_preview: "Vorschau",
    do_magic_preview_empty: "Filter hinzuf\xFCgen, um Dateien zu sehen",
    do_magic_preview_none: "Keine Dateien passen",
    do_magic_preview_count: "<strong>{count}</strong> Dateien erscheinen in diesem Magic Folder:",
    do_magic_apply: "Magie anwenden \u2728"
  },
  it: {
    settings_title: "Magic Folders \u2013 Impostazioni",
    settings_show_tooltips_name: "Mostra tooltip",
    settings_show_tooltips_desc: "Mostra tag e filtri al passaggio del mouse.",
    settings_language_name: "Lingua",
    settings_language_desc: "Scegli la lingua del plugin.",
    settings_custom_icons_name: "Usa icone personalizzate",
    settings_custom_icons_desc: "Abilita icone da una cartella del vault.",
    settings_custom_icons_path_name: "Cartella icone",
    settings_custom_icons_path_desc: "Percorso cartella (vault o esterna) con icone (svg/png/jpg).",
    settings_show_new_badge_name: "Badge nuovi elementi",
    settings_show_new_badge_desc: "Mostra badge su cartelle chiuse con nuovi elementi.",
    settings_unread_highlight_name: "Evidenzia file non letti",
    settings_unread_highlight_desc: "Metti in grassetto i nuovi file finch\xE9 non vengono aperti.",
    settings_show_file_count_name: "Mostra conteggio file",
    settings_show_file_count_desc: "Mostra il numero di file accanto al nome della cartella.",
    settings_refresh_on_change_name: "Aggiornamento automatico",
    settings_refresh_on_change_desc: "Aggiorna quando i file cambiano.",
    menu_create_here: "Crea Magic Folder qui",
    menu_in_magic_folder: "In Magic Folder: {name}",
    menu_matched: "Corrisponde: {filters}",
    menu_open: "Apri",
    menu_open_source: "Apri nella cartella sorgente",
    menu_open_new_tab: "Apri in nuova scheda",
    menu_do_magic: "Do Magic (modifica filtri)",
    menu_edit: "Modifica Magic Folder",
    menu_move_up: "Sposta su",
    menu_move_down: "Sposta gi\xF9",
    menu_sort_name: "Ordina per: Nome",
    menu_sort_modified: "Ordina per: Modificato",
    menu_sort_created: "Ordina per: Data di creazione",
    menu_sort_type: "Ordina per: Tipo file",
    menu_sort_size: "Ordina per: Dimensione",
    menu_sort_tag: "Ordina per: Tag",
    menu_order_asc: "Ordine: Crescente",
    menu_order_desc: "Ordine: Decrescente",
    menu_refresh: "Aggiorna",
    menu_delete: "Elimina Magic Folder",
    menu_mark_read: "Segna come letto",
    menu_mark_unread: "Segna come non letto",
    menu_mark_all_read: "Segna tutto come letto",
    menu_mark_all_unread: "Segna tutto come non letto",
    command_create: "Crea Magic Folder",
    command_create_here: "Crea Magic Folder nella cartella corrente",
    command_refresh: "Aggiorna tutti i Magic Folders",
    notice_created: 'Magic Folder "{name}" creato!',
    notice_updated: 'Magic Folder "{name}" aggiornato!',
    notice_deleted: 'Magic Folder "{name}" eliminato!',
    notice_refresh: "{name} aggiornato!",
    notice_name_required: "Inserisci un nome per il tuo Magic Folder",
    notice_marked_all_read: 'Tutti i file in "{name}" segnati come letti.',
    notice_marked_all_unread: 'Tutti i file in "{name}" segnati come non letti.',
    modal_create_title: "Crea Magic Folder",
    modal_edit_title: "Modifica Magic Folder",
    modal_name_label: "Nome",
    modal_name_desc: "Il nome del tuo Magic Folder",
    modal_name_placeholder: "Il mio Magic Folder",
    modal_default_name: "Nuovo Magic Folder",
    modal_color_label: "Colore",
    modal_color_desc: "Scegli un colore per il tuo Magic Folder",
    modal_icon_label: "Icona",
    modal_icon_desc: "Scegli un\u2019icona per il tuo Magic Folder",
    modal_emoji_label: "Emoji (opzionale)",
    modal_emoji_desc: "Scegli un emoji per il tuo Magic Folder",
    modal_emoji_search: "Cerca emoji...",
    modal_custom_icons_label: "Icone personalizzate",
    modal_sort_by_label: "Ordina per",
    modal_sort_by_desc: "Come ordinare i file in questa cartella",
    modal_sort_name: "Nome (A-Z)",
    modal_sort_modified: "Ultima modifica",
    modal_sort_created: "Data di creazione",
    modal_sort_type: "Tipo file",
    modal_sort_size: "Dimensione file",
    modal_sort_tag: "Tag",
    modal_sort_asc: "\u2191 Crescente",
    modal_sort_desc: "\u2193 Decrescente",
    modal_cancel: "Annulla",
    modal_create: "Crea Magic Folder",
    modal_save: "Salva modifiche",
    do_magic_title: "Do Magic",
    do_magic_help: "Usa #tag, [[link]], .ext, folder:, ext:, o key:value.",
    do_magic_help_tags: "Tag: #progetto o #padre/figlio",
    do_magic_help_links: "Link: [[Nome nota]]",
    do_magic_help_folder: "Cartella: folder:Cartella/Sub",
    do_magic_help_ext: "Estensione: .pdf o ext:pdf",
    do_magic_help_frontmatter: "Frontmatter: chiave:valore",
    do_magic_help_multi: "Pi\xF9 token separati da spazi",
    do_magic_help_logic: "Usa OR / AND / NOT per combinare",
    do_magic_logic_label: "Aggiungi come: ",
    do_magic_input_placeholder: "Digita # per tag, [[ per link, . per estensioni...",
    do_magic_add: "Aggiungi",
    do_magic_preview: "Anteprima",
    do_magic_preview_empty: "Aggiungi filtri per vedere i file",
    do_magic_preview_none: "Nessun file corrisponde",
    do_magic_preview_count: "<strong>{count}</strong> file appariranno in questo Magic Folder:",
    do_magic_apply: "Applica magia \u2728"
  }
};
var MagicFoldersSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const t = this.plugin.t.bind(this.plugin);
    containerEl.createEl("h2", { text: t("settings_title") });
    new import_obsidian.Setting(containerEl).setName(t("settings_show_tooltips_name")).setDesc(t("settings_show_tooltips_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showTooltips).onChange(async (value) => {
        this.plugin.settings.showTooltips = value;
        await this.plugin.saveSettings();
        this.plugin.renderAllMagicFolders();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t("settings_refresh_on_change_name")).setDesc(t("settings_refresh_on_change_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.refreshOnChange).onChange(async (value) => {
        this.plugin.settings.refreshOnChange = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t("settings_show_new_badge_name")).setDesc(t("settings_show_new_badge_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showNewItemsBadge).onChange(async (value) => {
        this.plugin.settings.showNewItemsBadge = value;
        await this.plugin.saveSettings();
        this.plugin.renderAllMagicFolders();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t("settings_unread_highlight_name")).setDesc(t("settings_unread_highlight_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.highlightUnreadFiles).onChange(async (value) => {
        this.plugin.settings.highlightUnreadFiles = value;
        await this.plugin.saveSettings();
        this.plugin.renderAllMagicFolders();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t("settings_show_file_count_name")).setDesc(t("settings_show_file_count_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showFileCount).onChange(async (value) => {
        this.plugin.settings.showFileCount = value;
        await this.plugin.saveSettings();
        this.plugin.renderAllMagicFolders();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t("settings_language_name")).setDesc(t("settings_language_desc")).addDropdown((dropdown) => {
      dropdown.addOption("fr", "Fran\xC3\xA7ais").addOption("en", "English").addOption("es", "Espa\xC3\xB1ol").addOption("de", "Deutsch").addOption("it", "Italiano").setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t("settings_custom_icons_name")).setDesc(t("settings_custom_icons_desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.customIconsEnabled).onChange(async (value) => {
        this.plugin.settings.customIconsEnabled = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const iconPathSetting = new import_obsidian.Setting(containerEl).setName(t("settings_custom_icons_path_name")).setDesc(t("settings_custom_icons_path_desc"));
    iconPathSetting.addText((text) => {
      text.setPlaceholder("Assets/Icons").setValue(this.plugin.settings.customIconFolder || "").onChange(async (value) => {
        this.plugin.settings.customIconFolder = value.trim();
        await this.plugin.saveSettings();
      });
    });
    if (!this.plugin.settings.customIconsEnabled) {
      iconPathSetting.setDisabled(true);
    }
  }
};
var MagicFoldersPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.virtualElements = [];
    this.styleEl = null;
    this.fileExplorerButton = null;
    this.refreshTimeout = null;
    this.matchedFiltersCache = /* @__PURE__ */ new Map();
    this.mutationObserver = null;
    this.isRendering = false;
    this.isInitialLoad = true;
    this.tooltipElements = /* @__PURE__ */ new Set();
    this.tooltipTimers = /* @__PURE__ */ new Map();
    this.draggingMagicFolderId = null;
    this.customIconResourceCache = /* @__PURE__ */ new Map();
    this.customIconLocalStorageKeyPrefix = "magic-folders-icon-cache:";
    this._commandBlocked = false;
    this._revealBlockCount = 0;
    this._magicSelectionKeepTimers = [];
    this._lastMagicActiveTitleEl = null;
    this._blockedExplorerMethodNames = [
      "revealInFolder",
      "expandFolderForFile",
      "expandParentsForFile",
      "expandFolderForPath",
      "expandPath",
      "revealFile"
    ];
  }
  t(key, vars) {
    const lang = this.settings && this.settings.language || "en";
    const dict = TRANSLATIONS[lang] || TRANSLATIONS.en;
    let out = dict[key] || TRANSLATIONS.en[key] || key;
    if (vars) {
      out = out.replace(/\{(\w+)\}/g, (_, k) => {
        var _a;
        return String((_a = vars[k]) != null ? _a : `{${k}}`);
      });
    }
    return out;
  }
  async onload() {
    console.log("Loading Magic Folders plugin");
    await this.loadSettings();
    this.injectStyles();
    setTimeout(() => {
      this.addSettingTab(new MagicFoldersSettingTab(this.app, this));
    }, 0);
    this.app.workspace.onLayoutReady(() => {
      this.insertCreateButton();
      this.renderFromCache();
      setTimeout(() => {
        this.refreshInBackground();
      }, 100);
      this.setupFileExplorerObserver();
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file, source) => {
        this.onFileMenu(menu, file, source);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        var _a;
        if (!file) return;
        this.markFileAsRead(file.path);
        if (this._revealBlockCount > 0 && ((_a = this._lastMagicActiveTitleEl) == null ? void 0 : _a.isConnected)) {
          this.setMagicFileActive(this._lastMagicActiveTitleEl);
        }
      })
    );
    if (this.settings.refreshOnChange) {
      this.registerEvent(
        this.app.vault.on("modify", () => this.scheduleRefresh())
      );
      this.registerEvent(
        this.app.vault.on("create", () => this.scheduleRefresh())
      );
      this.registerEvent(
        this.app.vault.on("delete", () => this.scheduleRefresh())
      );
      this.registerEvent(
        this.app.vault.on("rename", () => this.scheduleRefresh())
      );
      this.registerEvent(
        this.app.metadataCache.on("changed", () => this.scheduleRefresh())
      );
    }
    this.addCommand({
      id: "create-magic-folder",
      name: this.t("command_create"),
      callback: () => this.openCreateMagicFolderModal()
    });
    this.addCommand({
      id: "create-magic-folder-here",
      name: this.t("command_create_here"),
      callback: () => {
        this.openCreateMagicFolderModal();
      }
    });
    this.addCommand({
      id: "refresh-magic-folders",
      name: this.t("command_refresh"),
      callback: () => this.renderAllMagicFolders()
    });
    this.addRibbonIcon("wand-2", this.t("command_create"), () => {
      this.openCreateMagicFolderModal();
    });
  }
  onunload() {
    console.log("Unloading Magic Folders plugin");
    this.removeAllVirtualFolders();
    this.clearTooltips();
    for (const timer of this._magicSelectionKeepTimers) {
      window.clearTimeout(timer);
    }
    this._magicSelectionKeepTimers = [];
    this._lastMagicActiveTitleEl = null;
    if (this._commandBlocked || this._revealBlockCount > 0) {
      this._revealBlockCount = 1;
      this.unblockRevealInFolder(this.getFileExplorer());
    }
    if (this.styleEl) this.styleEl.remove();
    if (this.fileExplorerButton) this.fileExplorerButton.remove();
    if (this.refreshTimeout) {
      clearTimeout(this.refreshTimeout);
      this.refreshTimeout = null;
    }
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
      this.mutationObserver = null;
    }
  }
  async loadSettings() {
    const loaded = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loaded);
    for (const folder of this.settings.magicFolders) {
      for (const filter of folder.filters) {
        if (filter.logic === void 0) {
          filter.logic = "OR";
        }
      }
      if (folder.customIconSize === void 0) {
        folder.customIconSize = 28;
      }
      if (folder.customIconKeepRatio === void 0) {
        folder.customIconKeepRatio = false;
      }
      if (folder.customIconOffsetY === void 0) {
        folder.customIconOffsetY = 0;
      }
      if (folder.customIconOffsetX === void 0) {
        folder.customIconOffsetX = 0;
      }
      if (folder.hideName !== void 0) {
        folder.hideCustomIconName = folder.hideName;
      } else {
        folder.hideName = folder.hideCustomIconName || false;
      }
      if (folder.customIconPath) {
        const resource = this.getCustomIconResource(folder.customIconPath);
        if (resource) this.setCustomIconCache(folder.customIconPath, resource);
      }
    }
    if (this.settings.showTooltips === void 0) {
      this.settings.showTooltips = true;
    }
    if (!this.settings.language) {
      this.settings.language = "fr";
    }
    if (this.settings.customIconsEnabled === void 0) {
      this.settings.customIconsEnabled = false;
    }
    if (this.settings.customIconFolder === void 0) {
      this.settings.customIconFolder = "";
    }
    if (this.settings.showNewItemsBadge === void 0) {
      this.settings.showNewItemsBadge = true;
    }
    if (this.settings.highlightUnreadFiles === void 0) {
      this.settings.highlightUnreadFiles = true;
    }
    if (this.settings.showFileCount === void 0) {
      this.settings.showFileCount = true;
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onFileMenu(menu, file, source) {
    if (!(file instanceof import_obsidian.TFile) && !(file instanceof import_obsidian.TFolder)) return;
    if (file instanceof import_obsidian.TFolder) {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle(this.t("menu_create_here")).setIcon("wand-2").onClick(() => {
          this.openCreateMagicFolderModal();
        });
      });
    }
    if (file instanceof import_obsidian.TFile) {
      for (const magicFolder of this.settings.magicFolders) {
        const cache = this.matchedFiltersCache.get(magicFolder.id);
        if (cache == null ? void 0 : cache.has(file.path)) {
          menu.addSeparator();
          menu.addItem((item) => {
            item.setTitle(this.t("menu_in_magic_folder", { name: magicFolder.name })).setIcon("sparkles").setDisabled(true);
          });
          const matchedFilters = cache.get(file.path) || [];
          if (matchedFilters.length > 0) {
            menu.addItem((item) => {
              const filterText = matchedFilters.map((f) => this.formatFilterLabel(f)).join(", ");
              item.setTitle(this.t("menu_matched", { filters: filterText })).setIcon("tag").setDisabled(true);
            });
          }
          break;
        }
      }
    }
  }
  injectStyles() {
    this.styleEl = document.createElement("style");
    this.styleEl.id = "magic-folders-styles";
    this.styleEl.textContent = `
			/* Agrandissement de la fen\xEAtre modale */
			.modal.magic-folder-modal {
				min-width: 600px;
				max-width: 900px;
				min-height: 600px;
				display: flex;
				flex-direction: column;
			}
			.modal-content.magic-folder-modal,
			.magic-folder-modal {
				overflow-y: auto;
				box-sizing: border-box;
			}
			body.magic-folder-edit-modal-open .modal-bg {
				background-color: transparent !important;
				backdrop-filter: none !important;
			}
			.magic-folder-modal .setting-item {
				border-top: none;
				padding: 12px 0;
			}
			.magic-folder-modal .setting-item {
				flex-direction: column;
				align-items: stretch;
			}
			.magic-folder-modal .setting-item-info {
				width: 100%;
				margin-bottom: 6px;
			}
			.magic-folder-modal .setting-item-name {
				margin-bottom: 2px;
			}
			.emoji-picker-container {
				margin: 12px 0 24px 0;
				width: 100%;
				display: flex;
				flex-direction: column;
				align-items: stretch;
				gap: 8px;
			}
			.emoji-picker-container input {
				width: 100%;
				margin-bottom: 10px;
				font-size: 16px;
				padding: 6px 10px;
				border-radius: 6px;
				border: 1px solid var(--background-modifier-border);
			}
			.emoji-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
				gap: 8px;
				height: 200px;
				min-height: 200px;
				max-height: 200px;
				overflow-y: scroll !important;
				margin-bottom: 10px;
				background: var(--background-secondary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				padding: 8px;
				align-content: start;
			}
			.emoji-btn {
				font-size: 28px;
				background: var(--background-modifier-hover);
				border: none;
				border-radius: 8px;
				cursor: pointer;
				padding: 6px 0;
				transition: background 0.15s, box-shadow 0.15s;
			}
			.emoji-btn.selected {
				background: var(--interactive-accent);
				box-shadow: 0 0 0 2px var(--text-accent);
			}
			.custom-icon-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
				gap: 8px;
				margin-top: 6px;
				width: 100%;
				min-width: 0;
				justify-items: center;
			}
			.custom-icon-btn {
				background: var(--background-modifier-hover);
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				padding: 6px;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 40px;
			}
			.magic-custom-icon-control {
				width: 100%;
				min-width: 0;
			}
			.magic-custom-icon-setting .setting-item-control {
				display: block;
				width: 100%;
			}
			.magic-custom-icon-setting {
				flex-direction: column;
				align-items: stretch;
			}
			.magic-custom-icon-setting .setting-item-info {
				width: 100%;
				margin-bottom: 6px;
			}
			.magic-custom-icon-setting .setting-item-name {
				margin-bottom: 2px;
			}
			.magic-custom-icon-wrap {
				display: flex;
				flex-direction: column;
				gap: 10px;
				width: 100%;
			}
			.custom-icon-btn.selected {
				box-shadow: 0 0 0 2px var(--text-accent);
				border-color: var(--text-accent);
				background: var(--background-secondary);
			}
			.magic-folder-custom-icon {
				object-fit: contain;
			}
			.custom-icon-btn .magic-folder-custom-icon {
				width: 28px;
				height: 28px;
			}
			.magic-custom-icon-preview-row {
				display: flex;
				align-items: center;
				gap: 12px;
				margin: 4px 0 0 0;
				width: 100%;
			}
			.magic-custom-icon-size {
				display: flex;
				align-items: center;
				gap: 10px;
				flex: 1;
			}
			.magic-custom-icon-size input[type="range"] {
				width: 100%;
			}
			.magic-custom-icon-ratio {
				display: flex;
				align-items: center;
				gap: 6px;
				margin-left: 6px;
				white-space: nowrap;
			}
			.magic-custom-icon-offset {
				display: flex;
				align-items: center;
				gap: 6px;
				margin-left: 6px;
				white-space: nowrap;
			}
			.magic-custom-icon-offset input[type="range"] {
				width: 120px;
			}
			.magic-folder-color-input {
				width: 42px;
				height: 32px;
				border: none;
				background: transparent;
				padding: 0;
				margin-left: 8px;
				cursor: pointer;
			}
			.magic-folder-color-opacity {
				display: flex;
				align-items: center;
				gap: 8px;
				margin-top: 6px;
			}
			.magic-folder-color-opacity input[type="range"] {
				width: 140px;
			}
			.magic-folder-custom-icon.is-loading {
				opacity: 0.5;
			}
			.magic-folder-icon-only .nav-folder-title-content {
				display: none !important;
			}
			.magic-file-new .nav-file-title {
				font-weight: 900;
				border: none;
				border-radius: 0;
				background: transparent;
				margin: 2px 0;
			}
			.magic-folder-new-badge {
				font-size: 10px;
				background: var(--interactive-accent);
				color: white;
				padding: 1px 5px;
				border-radius: 10px;
				margin-left: 6px;
			}
			.magic-folder-new-badge.is-hidden {
				display: none;
			}
			.modal-button-container {
				display: flex;
				justify-content: flex-end;
				gap: 16px;
				margin-top: 32px;
				padding-top: 12px;
				padding-bottom: 12px;
				position: sticky;
				bottom: 0;
				background: var(--background-primary);
				border-top: 1px solid var(--background-modifier-border);
				z-index: 10;
			}
			.magic-folder-create-btn {
				color: var(--text-muted);
				transition: color 0.2s ease;
			}
			.magic-folder-create-btn:hover {
				color: var(--text-accent);
			}
			.magic-folder-item {
				position: relative;
			}
			.magic-folder-item .nav-folder-title {
				border-left: 3px solid var(--magic-folder-color-bg, var(--text-accent));
				padding-left: 6px !important;
				/* Default color-mix logic for light theme */
				background: linear-gradient(90deg, 
					color-mix(in srgb, var(--magic-folder-color-bg, var(--text-accent)) 15%, transparent) 0%,
					transparent 100%
				);
			}
			/* Dark theme specific override to ensure overlay is visible and correct */
			.theme-dark .magic-folder-item .nav-folder-title {
				background: linear-gradient(90deg, 
					color-mix(in srgb, var(--magic-folder-color-bg, var(--text-accent)) 15%, transparent) 0%,
					transparent 100%
				);
			}
			.magic-folder-item .nav-folder-title:hover {
				background: linear-gradient(90deg, 
					color-mix(in srgb, var(--magic-folder-color-bg, var(--text-accent)) 25%, transparent) 0%,
					transparent 100%
				);
			}
			.magic-folder-item .magic-folder-icon {
				color: var(--magic-folder-color, var(--text-accent));
				margin-right: 4px;
				display: inline-flex;
				align-items: center;
			}
			.magic-folder-item .magic-folder-icon svg {
				width: 14px;
				height: 14px;
			}
			.magic-folder-item .nav-folder-title-content {
				color: var(--magic-folder-color, var(--text-accent)) !important;
				font-weight: 500;
			}
			.magic-folder-item .magic-file-count {
				font-size: 10px;
				color: var(--text-muted);
				margin-left: 6px;
				background: var(--background-modifier-hover);
				padding: 1px 6px;
				border-radius: 10px;
			}
			.magic-folder-item .nav-file-title {
				opacity: 0.9;
				position: relative;
			}
			.magic-folder-item .nav-file-title.is-active {
				background-color: var(--background-modifier-active-hover) !important;
				border-radius: 4px;
			}
			.magic-folder-item .nav-file.is-active > .nav-file-title {
				background-color: var(--background-modifier-active-hover) !important;
				border-radius: 4px;
			}
			.magic-folder-item .nav-file-title:hover {
				opacity: 1;
				background-color: var(--background-modifier-hover);
			}
			.magic-folder-item.is-being-dragged {
				opacity: 0.6;
			}
			.magic-folder-item.magic-drop-target > .nav-folder-title {
				outline: 2px dashed var(--interactive-accent);
				outline-offset: 2px;
				background-color: var(--background-modifier-hover);
			}
			.magic-file-tags-tooltip {
				position: fixed;
				left: 0;
				top: 0;
				transform: translateX(-50%) translateY(-100%);
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				padding: 6px 10px;
				font-size: 11px;
				white-space: nowrap;
				z-index: 999999 !important;
				box-shadow: 0 4px 12px rgba(0,0,0,0.15);
				opacity: 0;
				visibility: hidden;
				transition: opacity 0.15s ease, visibility 0.15s ease;
				pointer-events: none;
			}
			.magic-file-tags-tooltip.is-visible {
				opacity: 1 !important;
				visibility: visible !important;
			}
			.magic-file-tags-tooltip::after {
				content: '';
				position: absolute;
				top: 100%;
				left: 50%;
				transform: translateX(-50%);
				border: 6px solid transparent;
				border-top-color: var(--background-modifier-border);
			}
			.magic-file-tags-tooltip .tag-pill {
				display: inline-block;
				background: var(--magic-folder-color, var(--text-accent));
				color: white;
				padding: 2px 8px;
				border-radius: 12px;
				margin: 2px;
				font-size: 10px;
				font-weight: 500;
			}
			.magic-help-row {
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 8px;
				margin: 8px 0 6px 0;
			}
			.magic-help-text {
				font-size: 12px;
				color: var(--text-muted);
			}
			.magic-help-wrap {
				position: relative;
				display: inline-flex;
				align-items: center;
			}
			.magic-help-btn {
				width: 22px;
				height: 22px;
				border-radius: 50%;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-secondary);
				color: var(--text-muted);
				display: inline-flex;
				align-items: center;
				justify-content: center;
				cursor: pointer;
			}
			.magic-help-btn:hover {
				color: var(--text-normal);
				border-color: var(--text-accent);
			}
			.magic-help-tooltip {
				position: absolute;
				right: 0;
				top: 28px;
				min-width: 260px;
				max-width: 320px;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				padding: 8px 10px;
				box-shadow: 0 6px 18px rgba(0,0,0,0.2);
				font-size: 11px;
				line-height: 1.35;
				opacity: 0;
				visibility: hidden;
				transition: opacity 0.15s ease, visibility 0.15s ease;
				z-index: 9999;
			}
			.magic-help-wrap.is-open .magic-help-tooltip {
				opacity: 1;
				visibility: visible;
			}
			.magic-quick-insert {
				display: flex;
				flex-wrap: wrap;
				gap: 6px;
				margin: 6px 0 12px 0;
			}
			.magic-quick-btn {
				padding: 4px 8px;
				border-radius: 999px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-secondary);
				color: var(--text-muted);
				cursor: pointer;
				font-size: 11px;
			}
			.magic-quick-btn:hover {
				color: var(--text-normal);
				border-color: var(--text-accent);
			}
			.magic-folder-badge {
				font-size: 8px;
				background: var(--magic-folder-color, var(--text-accent));
				color: white;
				padding: 1px 4px;
				border-radius: 3px;
				margin-left: 4px;
				text-transform: uppercase;
				font-weight: bold;
			}
			@media (max-width: 768px) {
				.modal.magic-folder-modal,
				.modal-content.magic-folder-modal,
				.magic-folder-modal {
					width: 95vw;
					max-width: 95vw;
					min-width: 0;
				}
				.emoji-grid {
					grid-template-columns: repeat(auto-fill, minmax(35px, 1fr));
				}
			}
		`;
    document.head.appendChild(this.styleEl);
  }
  getFileExplorer() {
    const leaves = this.app.workspace.getLeavesOfType("file-explorer");
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return void 0;
  }
  getFileExplorers() {
    return this.app.workspace.getLeavesOfType("file-explorer").map((leaf) => leaf == null ? void 0 : leaf.view).filter((view) => !!view);
  }
  getFileExplorerContainer(fileExplorer) {
    var _a, _b, _c, _d;
    const navContainer = (_a = fileExplorer == null ? void 0 : fileExplorer.dom) == null ? void 0 : _a.navFileContainerEl;
    if (navContainer instanceof HTMLElement) return navContainer;
    const rootChildren = (_d = (_c = (_b = fileExplorer == null ? void 0 : fileExplorer.dom) == null ? void 0 : _b.infinityScroll) == null ? void 0 : _c.rootEl) == null ? void 0 : _d.childrenEl;
    if (rootChildren instanceof HTMLElement) return rootChildren;
    const containerEl = fileExplorer.containerEl;
    if (!containerEl) return null;
    return containerEl.querySelector(".nav-files-container");
  }
  setMagicFileActive(titleEl) {
    const explorer = this.getFileExplorer();
    const container = explorer ? this.getFileExplorerContainer(explorer) : null;
    if (container) {
      container.querySelectorAll(".nav-file-title.is-active").forEach((el) => {
        if (!el.closest(".magic-folder-item")) {
          el.classList.remove("is-active");
        }
      });
      container.querySelectorAll(".nav-file.is-active").forEach((el) => {
        if (!el.closest(".magic-folder-item")) {
          el.classList.remove("is-active");
        }
      });
    }
    const magicRoot = titleEl.closest(".magic-folder-item");
    if (!magicRoot) return;
    magicRoot.querySelectorAll(".nav-file-title.is-active").forEach((el) => el.classList.remove("is-active"));
    magicRoot.querySelectorAll(".nav-file.is-active").forEach((el) => el.classList.remove("is-active"));
    titleEl.classList.add("is-active");
    const fileEl = titleEl.closest(".nav-file");
    if (fileEl) fileEl.classList.add("is-active");
  }
  keepMagicFileActive(titleEl, durationMs = 4e3) {
    const checkpoints = [0, 50, 120, 250, 500, 900, 1400, 2200, 3200, 4e3].filter((ms) => ms <= durationMs);
    for (const ms of checkpoints) {
      const timer = window.setTimeout(() => {
        if (!titleEl.isConnected) return;
        this.setMagicFileActive(titleEl);
      }, ms);
      this._magicSelectionKeepTimers.push(timer);
    }
  }
  collectExplorerMethodsToBlock(explorer) {
    const names = new Set(this._blockedExplorerMethodNames);
    const pattern = /(reveal|expand|ensurevisible|setactive|select|focus|scrollto)/i;
    let obj = explorer;
    let depth = 0;
    while (obj && depth < 4) {
      for (const methodName of Object.getOwnPropertyNames(obj)) {
        if (methodName === "constructor") continue;
        if (names.has(methodName)) continue;
        if (!pattern.test(methodName)) continue;
        const descriptor = Object.getOwnPropertyDescriptor(obj, methodName);
        if (descriptor && typeof descriptor.value === "function") {
          names.add(methodName);
        }
      }
      obj = Object.getPrototypeOf(obj);
      depth++;
    }
    return Array.from(names);
  }
  patchExplorerMethodsForBlock(explorer) {
    var _a;
    if (!explorer) return;
    const originalMethods = (_a = explorer._magicOriginalExplorerMethods) != null ? _a : {};
    explorer._magicOriginalExplorerMethods = originalMethods;
    const methodsToBlock = this.collectExplorerMethodsToBlock(explorer);
    for (const methodName of methodsToBlock) {
      const method = explorer[methodName];
      if (typeof method === "function" && !originalMethods[methodName]) {
        originalMethods[methodName] = method;
        explorer[methodName] = () => {
          return;
        };
      }
    }
  }
  restoreExplorerMethodsAfterBlock(explorer) {
    if (!explorer) return;
    const originalMethods = explorer._magicOriginalExplorerMethods;
    if (!originalMethods) return;
    for (const methodName of Object.keys(originalMethods)) {
      explorer[methodName] = originalMethods[methodName];
    }
    delete explorer._magicOriginalExplorerMethods;
  }
  blockRevealInFolder(explorer) {
    this._revealBlockCount++;
    if (this._revealBlockCount > 1) return;
    const explorers = this.getFileExplorers();
    if (explorer && !explorers.includes(explorer)) {
      explorers.push(explorer);
    }
    for (const explorerView of explorers) {
      this.patchExplorerMethodsForBlock(explorerView);
    }
    if (!this._commandBlocked) {
      this._commandBlocked = true;
      const commandManager = this.app.commands;
      if (commandManager && commandManager.commands) {
        const revealCommand = commandManager.commands["file-explorer:reveal-active-file"];
        if (revealCommand && !revealCommand._originalCallback) {
          revealCommand._originalCallback = revealCommand.callback;
          revealCommand.callback = () => {
            console.log("Magic Folders: commande reveal-active-file bloqu\xC3\xA9e");
          };
        }
      }
    }
  }
  unblockRevealInFolder(explorer) {
    if (this._revealBlockCount > 0) {
      this._revealBlockCount--;
    }
    if (this._revealBlockCount > 0) return;
    const explorers = this.getFileExplorers();
    if (explorer && !explorers.includes(explorer)) {
      explorers.push(explorer);
    }
    for (const explorerView of explorers) {
      this.restoreExplorerMethodsAfterBlock(explorerView);
    }
    if (this._commandBlocked) {
      this._commandBlocked = false;
      const commandManager = this.app.commands;
      if (commandManager && commandManager.commands) {
        const revealCommand = commandManager.commands["file-explorer:reveal-active-file"];
        if (revealCommand && revealCommand._originalCallback) {
          revealCommand.callback = revealCommand._originalCallback;
          delete revealCommand._originalCallback;
        }
      }
      console.log("Magic Folders: reveal d\xC3\xA9bloqu\xC3\xA9");
    }
  }
  setupFileExplorerObserver() {
    const fileExplorer = this.getFileExplorer();
    if (!fileExplorer) return;
    const containerEl = fileExplorer.containerEl;
    if (!containerEl) return;
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
    }
    this.mutationObserver = new MutationObserver((mutations) => {
      if (this.isRendering) return;
      const missingMagicFolderIds = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        for (const node of Array.from(mutation.removedNodes)) {
          if (node instanceof HTMLElement && node.classList.contains("magic-folder-item")) {
            const magicFolderId = node.getAttribute("data-magic-folder-id");
            if (magicFolderId) {
              missingMagicFolderIds.add(magicFolderId);
            }
          }
        }
      }
      if (missingMagicFolderIds.size > 0) {
        if (this.refreshTimeout) {
          clearTimeout(this.refreshTimeout);
        }
        this.refreshTimeout = setTimeout(() => {
          this.renderMissingMagicFolders(missingMagicFolderIds);
        }, 50);
      }
    });
    this.mutationObserver.observe(containerEl, {
      childList: true,
      subtree: true,
      attributes: false
    });
  }
  async renderMissingMagicFolders(missingIds) {
    var _a, _b, _c;
    if (this.isRendering) return;
    const fileExplorer = this.getFileExplorer();
    if (!fileExplorer) return;
    this.isRendering = true;
    try {
      const targetContainer = this.getFileExplorerContainer(fileExplorer);
      if (!targetContainer) return;
      for (const magicFolderId of missingIds) {
        const containerEl = fileExplorer.containerEl;
        const existingEl = containerEl.querySelector(`[data-magic-folder-id="${magicFolderId}"]`);
        if (existingEl) continue;
        const magicFolder = this.settings.magicFolders.find((f) => f.id === magicFolderId);
        if (!magicFolder) continue;
        const filesWithFilters = await this.getMatchingFilesWithFilters(magicFolder);
        const filterCache = /* @__PURE__ */ new Map();
        for (const item of filesWithFilters) {
          filterCache.set(item.file.path, item.matchedFilters);
        }
        this.matchedFiltersCache.set(magicFolder.id, filterCache);
        const folderEl = this.createMagicFolderDOM(magicFolder, filesWithFilters);
        targetContainer.insertBefore(folderEl, targetContainer.firstChild);
        this.virtualElements.push(folderEl);
      }
      (_c = (_b = (_a = fileExplorer.dom) == null ? void 0 : _a.infinityScroll) == null ? void 0 : _b.compute) == null ? void 0 : _c.call(_b);
    } finally {
      this.isRendering = false;
    }
  }
  getFolderElement(fileExplorer, folderPath) {
    var _a;
    if (!folderPath || folderPath === "" || folderPath === "/") {
      return this.getFileExplorerContainer(fileExplorer);
    }
    const containerEl = fileExplorer.containerEl;
    if (!containerEl) return null;
    let folderTitle = containerEl.querySelector(`.nav-folder-title[data-path="${folderPath}"]`);
    if (folderTitle) {
      const folderEl = folderTitle.closest(".nav-folder");
      if (folderEl) {
        const childrenEl = folderEl.querySelector(":scope > .nav-folder-children");
        if (childrenEl instanceof HTMLElement) {
          return childrenEl;
        }
      }
    }
    const treeItem = containerEl.querySelector(`.tree-item-self[data-path="${folderPath}"]`);
    if (treeItem) {
      const folderEl = treeItem.closest(".nav-folder, .tree-item");
      if (folderEl) {
        const childrenEl = folderEl.querySelector(":scope > .nav-folder-children, :scope > .tree-item-children");
        if (childrenEl instanceof HTMLElement) {
          return childrenEl;
        }
      }
    }
    const folderItem = (_a = fileExplorer.fileItems) == null ? void 0 : _a[folderPath];
    if (folderItem) {
      if (folderItem.childrenEl instanceof HTMLElement) {
        return folderItem.childrenEl;
      }
      const selfEl = folderItem.selfEl || folderItem.el;
      if (selfEl) {
        const parent = selfEl.closest(".nav-folder");
        if (parent) {
          const childrenEl = parent.querySelector(":scope > .nav-folder-children");
          if (childrenEl instanceof HTMLElement) {
            return childrenEl;
          }
        }
      }
    }
    return null;
  }
  insertCreateButton() {
    const navButtonsContainer = document.querySelector(".nav-buttons-container");
    if (!navButtonsContainer) {
      setTimeout(() => this.insertCreateButton(), 500);
      return;
    }
    if (navButtonsContainer.querySelector(".magic-folder-create-btn")) return;
    this.fileExplorerButton = document.createElement("div");
    this.fileExplorerButton.className = "nav-action-button magic-folder-create-btn clickable-icon";
    this.fileExplorerButton.setAttribute("aria-label", this.t("command_create"));
    (0, import_obsidian.setIcon)(this.fileExplorerButton, "wand-2");
    this.registerDomEvent(this.fileExplorerButton, "click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.openCreateMagicFolderModal();
    });
    navButtonsContainer.appendChild(this.fileExplorerButton);
  }
  scheduleRefresh() {
    if (this.refreshTimeout) {
      clearTimeout(this.refreshTimeout);
    }
    this.refreshTimeout = setTimeout(() => {
      this.renderAllMagicFolders();
    }, 500);
  }
  removeAllVirtualFolders() {
    for (const el of this.virtualElements) {
      el.remove();
    }
    this.virtualElements = [];
    this.matchedFiltersCache.clear();
    this.clearTooltips();
  }
  clearTooltips() {
    for (const tooltip of this.tooltipElements) {
      const timers = this.tooltipTimers.get(tooltip);
      if (timers == null ? void 0 : timers.show) window.clearTimeout(timers.show);
      if (timers == null ? void 0 : timers.hide) window.clearTimeout(timers.hide);
      tooltip.remove();
    }
    this.tooltipElements.clear();
    this.tooltipTimers.clear();
  }
  renderFromCache() {
    var _a, _b, _c;
    if (this.isRendering) return;
    if (!this.settings.cache || this.settings.cache.length === 0) {
      this.renderAllMagicFolders();
      return;
    }
    const fileExplorer = this.getFileExplorer();
    if (!fileExplorer) {
      setTimeout(() => this.renderFromCache(), 100);
      return;
    }
    this.isRendering = true;
    try {
      this.removeAllVirtualFolders();
      const containerEl = this.getFileExplorerContainer(fileExplorer);
      if (!containerEl) {
        this.isRendering = false;
        return;
      }
      const elements = [];
      for (const magicFolder of [...this.settings.magicFolders].reverse()) {
        const cachedData = this.settings.cache.find((c) => c.folderId === magicFolder.id);
        if (cachedData && cachedData.files.length > 0) {
          this.updateUnreadForFolder(
            magicFolder,
            cachedData.files.map((f) => f.path),
            cachedData.files.map((f) => f.path)
          );
          const folderEl = this.createMagicFolderDOMFromCache(magicFolder, cachedData.files);
          containerEl.insertBefore(folderEl, containerEl.firstChild);
          elements.push(folderEl);
          this.updateUnreadBadgeInDom(magicFolder.id);
        } else {
          const folderEl = this.createMagicFolderPlaceholder(magicFolder);
          containerEl.insertBefore(folderEl, containerEl.firstChild);
          elements.push(folderEl);
        }
      }
      this.virtualElements = elements;
      (_c = (_b = (_a = fileExplorer.dom) == null ? void 0 : _a.infinityScroll) == null ? void 0 : _b.compute) == null ? void 0 : _c.call(_b);
    } finally {
      this.isRendering = false;
    }
  }
  createMagicFolderPlaceholder(magicFolder) {
    const folderEl = document.createElement("div");
    folderEl.className = "tree-item nav-folder magic-folder-item is-loading";
    this.setMagicColorVars(folderEl, magicFolder.color);
    folderEl.setAttribute("data-magic-folder-id", magicFolder.id);
    const titleEl = document.createElement("div");
    titleEl.className = "tree-item-self is-clickable nav-folder-title";
    const magicIcon = document.createElement("span");
    magicIcon.className = "magic-folder-icon";
    const offsetX = magicFolder.customIconOffsetX || 0;
    const offsetY = magicFolder.customIconOffsetY || 0;
    const size = magicFolder.customIconSize || 28;
    if (magicFolder.customIconPath) {
      const resourcePath = this.getCustomIconResource(magicFolder.customIconPath);
      if (resourcePath) {
        const img = document.createElement("img");
        img.className = "magic-folder-custom-icon";
        img.src = resourcePath;
        img.loading = "eager";
        img.decoding = "async";
        img.style.height = `${size}px`;
        img.style.width = magicFolder.customIconKeepRatio ? "auto" : `${size}px`;
        if (offsetX !== 0 || offsetY !== 0) {
          img.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
        magicIcon.appendChild(img);
      } else if (magicFolder.emoji) {
        magicIcon.textContent = magicFolder.emoji;
        magicIcon.style.fontSize = `${size}px`;
        magicIcon.style.display = "inline-block";
        if (offsetX !== 0 || offsetY !== 0) {
          magicIcon.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
      } else {
        (0, import_obsidian.setIcon)(magicIcon, magicFolder.icon);
        const svg = magicIcon.querySelector("svg");
        if (svg) {
          svg.style.width = `${size}px`;
          svg.style.height = `${size}px`;
          if (offsetX !== 0 || offsetY !== 0) {
            svg.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
          }
        }
      }
    } else if (magicFolder.emoji) {
      magicIcon.textContent = magicFolder.emoji;
      magicIcon.style.fontSize = `${size}px`;
      magicIcon.style.display = "inline-block";
      if (offsetX !== 0 || offsetY !== 0) {
        magicIcon.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      }
    } else {
      (0, import_obsidian.setIcon)(magicIcon, magicFolder.icon);
      const svg = magicIcon.querySelector("svg");
      if (svg) {
        svg.style.width = `${size}px`;
        svg.style.height = `${size}px`;
        if (offsetX !== 0 || offsetY !== 0) {
          svg.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
      }
    }
    titleEl.appendChild(magicIcon);
    const titleContent = document.createElement("div");
    titleContent.className = "tree-item-inner nav-folder-title-content";
    titleContent.textContent = magicFolder.name;
    titleEl.appendChild(titleContent);
    if (magicFolder.hideName) {
      folderEl.addClass("magic-folder-icon-only");
      titleContent.style.setProperty("display", "none", "important");
    } else {
      titleContent.style.removeProperty("display");
    }
    const loadingBadge = document.createElement("span");
    loadingBadge.className = "magic-file-count";
    loadingBadge.textContent = "...";
    loadingBadge.style.opacity = "0.5";
    if (!this.settings.showFileCount) {
      loadingBadge.style.display = "none";
    }
    titleEl.appendChild(loadingBadge);
    folderEl.appendChild(titleEl);
    return folderEl;
  }
  createMagicFolderDOMFromCache(magicFolder, cachedFiles) {
    const folderEl = document.createElement("div");
    folderEl.className = "tree-item nav-folder magic-folder-item";
    this.setMagicColorVars(folderEl, magicFolder.color);
    folderEl.setAttribute("data-magic-folder-id", magicFolder.id);
    if (magicFolder.collapsed) {
      folderEl.addClass("is-collapsed");
    }
    const titleEl = document.createElement("div");
    titleEl.className = "tree-item-self is-clickable mod-collapsible nav-folder-title";
    titleEl.setAttribute("data-magic-folder-id", magicFolder.id);
    this.setupDragAndDrop(folderEl, titleEl, magicFolder);
    const collapseIcon = document.createElement("div");
    collapseIcon.className = `tree-item-icon collapse-icon nav-folder-collapse-indicator ${magicFolder.collapsed ? "is-collapsed" : ""}`;
    (0, import_obsidian.setIcon)(collapseIcon, "right-triangle");
    titleEl.appendChild(collapseIcon);
    const magicIcon = document.createElement("span");
    magicIcon.className = "magic-folder-icon";
    const offsetX = magicFolder.customIconOffsetX || 0;
    const offsetY = magicFolder.customIconOffsetY || 0;
    const size = magicFolder.customIconSize || 28;
    if (magicFolder.customIconPath) {
      const resourcePath = this.getCustomIconResource(magicFolder.customIconPath);
      if (resourcePath) {
        const img = document.createElement("img");
        img.className = "magic-folder-custom-icon";
        img.src = resourcePath;
        img.loading = "eager";
        img.decoding = "async";
        img.style.height = `${size}px`;
        img.style.width = magicFolder.customIconKeepRatio ? "auto" : `${size}px`;
        if (offsetX !== 0 || offsetY !== 0) {
          img.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
        magicIcon.appendChild(img);
      } else if (magicFolder.emoji) {
        magicIcon.textContent = magicFolder.emoji;
        magicIcon.style.fontSize = `${size}px`;
        magicIcon.style.display = "inline-block";
        if (offsetX !== 0 || offsetY !== 0) {
          magicIcon.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
      } else {
        (0, import_obsidian.setIcon)(magicIcon, magicFolder.icon);
        const svg = magicIcon.querySelector("svg");
        if (svg) {
          svg.style.width = `${size}px`;
          svg.style.height = `${size}px`;
          if (offsetX !== 0 || offsetY !== 0) {
            svg.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
          }
        }
      }
    } else if (magicFolder.emoji) {
      magicIcon.textContent = magicFolder.emoji;
      magicIcon.style.fontSize = `${size}px`;
      magicIcon.style.display = "inline-block";
      if (offsetX !== 0 || offsetY !== 0) {
        magicIcon.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      }
    } else {
      (0, import_obsidian.setIcon)(magicIcon, magicFolder.icon);
      const svg = magicIcon.querySelector("svg");
      if (svg) {
        svg.style.width = `${size}px`;
        svg.style.height = `${size}px`;
        if (offsetX !== 0 || offsetY !== 0) {
          svg.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
      }
    }
    titleEl.appendChild(magicIcon);
    const titleContent = document.createElement("div");
    titleContent.className = "tree-item-inner nav-folder-title-content";
    titleContent.textContent = magicFolder.name;
    titleEl.appendChild(titleContent);
    if (magicFolder.hideName) {
      folderEl.addClass("magic-folder-icon-only");
      titleContent.style.setProperty("display", "none", "important");
    } else {
      titleContent.style.removeProperty("display");
    }
    if (this.settings.showFileCount) {
      const countBadge = document.createElement("span");
      countBadge.className = "magic-file-count";
      countBadge.textContent = String(cachedFiles.length);
      titleEl.appendChild(countBadge);
    }
    const newBadge = document.createElement("span");
    newBadge.className = "magic-folder-new-badge";
    const newCount = this.getNewItemsCount(magicFolder);
    if (newCount > 0) {
      newBadge.textContent = String(newCount);
    } else {
      newBadge.addClass("is-hidden");
    }
    titleEl.appendChild(newBadge);
    folderEl.appendChild(titleEl);
    const childrenEl = document.createElement("div");
    childrenEl.className = "tree-item-children nav-folder-children";
    childrenEl.style.display = magicFolder.collapsed ? "none" : "block";
    const unreadSet = this.settings.highlightUnreadFiles && Array.isArray(magicFolder.unreadFilePaths) ? new Set(magicFolder.unreadFilePaths) : null;
    for (const cachedFile of cachedFiles) {
      const isNew = unreadSet ? unreadSet.has(cachedFile.path) : false;
      const fileEl = this.createFileDOMFromCache(cachedFile, magicFolder.color, magicFolder.name, magicFolder.id, isNew);
      childrenEl.appendChild(fileEl);
    }
    folderEl.appendChild(childrenEl);
    this.registerDomEvent(titleEl, "click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      const isCollapsed = folderEl.hasClass("is-collapsed");
      if (isCollapsed) {
        folderEl.removeClass("is-collapsed");
        collapseIcon.removeClass("is-collapsed");
        childrenEl.style.display = "block";
      } else {
        folderEl.addClass("is-collapsed");
        collapseIcon.addClass("is-collapsed");
        childrenEl.style.display = "none";
      }
      if (isCollapsed) {
        this.updateUnreadBadgeInDom(magicFolder.id);
      }
      const folder = this.settings.magicFolders.find((f) => f.id === magicFolder.id);
      if (folder) {
        folder.collapsed = !isCollapsed;
        this.saveSettings();
        this.updateUnreadBadgeInDom(magicFolder.id);
      }
    });
    this.registerDomEvent(titleEl, "contextmenu", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.showMagicFolderContextMenu(e, magicFolder);
    });
    return folderEl;
  }
  createFileDOMFromCache(cachedFile, folderColor, folderName, folderId, isNew) {
    const fileEl = document.createElement("div");
    fileEl.className = "tree-item nav-file";
    if (isNew) fileEl.addClass("magic-file-new");
    this.setMagicColorVars(fileEl, folderColor);
    const titleEl = document.createElement("div");
    titleEl.className = "tree-item-self is-clickable nav-file-title";
    titleEl.setAttribute("data-path", cachedFile.path);
    const titleContent = document.createElement("div");
    titleContent.className = "tree-item-inner nav-file-title-content";
    titleContent.textContent = cachedFile.basename;
    titleEl.appendChild(titleContent);
    const extEl = document.createElement("span");
    extEl.className = "nav-file-tag";
    extEl.textContent = cachedFile.extension;
    titleEl.appendChild(extEl);
    fileEl.appendChild(titleEl);
    this.attachMatchedFiltersTooltip(titleEl, cachedFile.matchedFilters || []);
    this.registerDomEvent(titleEl, "click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      const explorer = this.getFileExplorer();
      const blockDurationMs = 4e3;
      this._lastMagicActiveTitleEl = titleEl;
      this.setMagicFileActive(titleEl);
      this.keepMagicFileActive(titleEl, blockDurationMs);
      this.blockRevealInFolder(explorer);
      try {
        await this.app.workspace.openLinkText(cachedFile.path, "", e.ctrlKey || e.metaKey);
      } finally {
        setTimeout(() => {
          this.keepMagicFileActive(titleEl, 600);
          this.unblockRevealInFolder(explorer);
        }, blockDurationMs);
      }
    });
    this.registerDomEvent(titleEl, "contextmenu", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.showMagicFileContextMenu(e, cachedFile.path, cachedFile.matchedFilters || [], folderName, folderId);
    });
    return fileEl;
  }
  async refreshInBackground() {
    const newCache = [];
    let unreadChanged = false;
    for (const magicFolder of this.settings.magicFolders) {
      const filesWithFilters = await this.getMatchingFilesWithFilters(magicFolder);
      const cachedFiles = filesWithFilters.map((f) => ({
        path: f.file.path,
        basename: f.file.basename,
        extension: f.file.extension,
        matchedFilters: f.matchedFilters
      }));
      const previousCache = this.settings.cache.find((c) => c.folderId === magicFolder.id);
      const previousPaths = previousCache ? previousCache.files.map((f) => f.path) : null;
      if (this.updateUnreadForFolder(magicFolder, cachedFiles.map((f) => f.path), previousPaths)) {
        unreadChanged = true;
      }
      newCache.push({
        folderId: magicFolder.id,
        files: cachedFiles,
        lastUpdated: Date.now()
      });
    }
    this.settings.cache = newCache;
    await this.saveSettings();
    this.isInitialLoad = false;
    await this.renderAllMagicFolders();
  }
  async updateCacheForFolder(folderId) {
    const magicFolder = this.settings.magicFolders.find((f) => f.id === folderId);
    if (!magicFolder) return;
    const filesWithFilters = await this.getMatchingFilesWithFilters(magicFolder);
    const cachedFiles = filesWithFilters.map((f) => ({
      path: f.file.path,
      basename: f.file.basename,
      extension: f.file.extension,
      matchedFilters: f.matchedFilters
    }));
    const existingIndex = this.settings.cache.findIndex((c) => c.folderId === folderId);
    const previousPaths = existingIndex >= 0 ? this.settings.cache[existingIndex].files.map((f) => f.path) : null;
    this.updateUnreadForFolder(magicFolder, cachedFiles.map((f) => f.path), previousPaths);
    const cacheEntry = {
      folderId,
      files: cachedFiles,
      lastUpdated: Date.now()
    };
    if (existingIndex >= 0) {
      this.settings.cache[existingIndex] = cacheEntry;
    } else {
      this.settings.cache.push(cacheEntry);
    }
    await this.saveSettings();
  }
  async renderAllMagicFolders() {
    var _a, _b, _c;
    if (this.isRendering) return;
    this.isRendering = true;
    try {
      this.removeAllVirtualFolders();
      const fileExplorer = this.getFileExplorer();
      if (!fileExplorer) {
        console.warn("Magic Folders: File explorer not found");
        return;
      }
      const containerEl = this.getFileExplorerContainer(fileExplorer);
      if (!containerEl) {
        console.warn("Magic Folders: Container not found");
        return;
      }
      const elements = [];
      for (const magicFolder of [...this.settings.magicFolders].reverse()) {
        const filesWithFilters = await this.getMatchingFilesWithFilters(magicFolder);
        const previousCache = this.settings.cache.find((c) => c.folderId === magicFolder.id);
        const previousPaths = previousCache ? previousCache.files.map((f) => f.path) : null;
        this.updateUnreadForFolder(magicFolder, filesWithFilters.map((f) => f.file.path), previousPaths);
        const filterCache = /* @__PURE__ */ new Map();
        for (const item of filesWithFilters) {
          filterCache.set(item.file.path, item.matchedFilters);
        }
        this.matchedFiltersCache.set(magicFolder.id, filterCache);
        if (!this.isInitialLoad) {
          const cachedFiles = filesWithFilters.map((f) => ({
            path: f.file.path,
            basename: f.file.basename,
            extension: f.file.extension,
            matchedFilters: f.matchedFilters
          }));
          const existingIndex = this.settings.cache.findIndex((c) => c.folderId === magicFolder.id);
          const cacheEntry = {
            folderId: magicFolder.id,
            files: cachedFiles,
            lastUpdated: Date.now()
          };
          if (existingIndex >= 0) {
            this.settings.cache[existingIndex] = cacheEntry;
          } else {
            this.settings.cache.push(cacheEntry);
          }
        }
        const folderEl = this.createMagicFolderDOM(magicFolder, filesWithFilters);
        containerEl.insertBefore(folderEl, containerEl.firstChild);
        elements.push(folderEl);
        this.updateUnreadBadgeInDom(magicFolder.id);
      }
      this.virtualElements = elements;
      (_c = (_b = (_a = fileExplorer.dom) == null ? void 0 : _a.infinityScroll) == null ? void 0 : _b.compute) == null ? void 0 : _c.call(_b);
      if (!this.isInitialLoad && this.settings.cache.length > 0) {
        this.saveSettings();
      }
    } finally {
      this.isRendering = false;
    }
  }
  async getMatchingFilesWithFilters(magicFolder) {
    const hasExtensionFilter = magicFolder.filters.some((f) => f.type === "extension");
    const allFiles = hasExtensionFilter ? this.app.vault.getFiles() : this.app.vault.getMarkdownFiles();
    const matchingFiles = [];
    for (const file of allFiles) {
      const result = await this.checkFileMatchesFilters(file, magicFolder.filters);
      if (result.matches) {
        matchingFiles.push({ file, matchedFilters: result.matchedFilters });
      }
    }
    return this.sortFilesWithFilters(matchingFiles, magicFolder.sortBy, magicFolder.sortOrder);
  }
  async checkFileMatchesFilters(file, filters) {
    if (filters.length === 0) return { matches: false, matchedFilters: [] };
    const cache = this.app.metadataCache.getFileCache(file);
    const orFilters = filters.filter((f) => (f.logic || "OR") === "OR");
    const andFilters = filters.filter((f) => f.logic === "AND");
    const notFilters = filters.filter((f) => f.logic === "NOT");
    const matchedFilters = [];
    for (const filter of notFilters) {
      if (this.filterMatchesFile(file, cache, filter)) {
        return { matches: false, matchedFilters: [] };
      }
    }
    let allAndMatch = true;
    for (const filter of andFilters) {
      if (this.filterMatchesFile(file, cache, filter)) {
        matchedFilters.push(filter);
      } else {
        allAndMatch = false;
      }
    }
    if (andFilters.length > 0 && !allAndMatch) {
      return { matches: false, matchedFilters: [] };
    }
    let anyOrMatch = orFilters.length === 0;
    for (const filter of orFilters) {
      if (this.filterMatchesFile(file, cache, filter)) {
        matchedFilters.push(filter);
        anyOrMatch = true;
      }
    }
    const matches = anyOrMatch && (andFilters.length === 0 || allAndMatch);
    return { matches, matchedFilters };
  }
  filterMatchesFile(file, cache, filter) {
    var _a;
    switch (filter.type) {
      case "tag":
        return this.fileHasTag(cache, filter.value);
      case "link":
        return this.fileHasLink(cache, filter.value);
      case "folder":
        return this.matchString(((_a = file.parent) == null ? void 0 : _a.path) || "", filter.value, filter.operator);
      case "extension":
        return this.matchString(file.extension, filter.value, filter.operator);
      case "frontmatter":
        return this.fileHasFrontmatter(cache, filter.value);
      default:
        return false;
    }
  }
  async getMatchedFilters(file, filters) {
    if (filters.length === 0) return [];
    const cache = this.app.metadataCache.getFileCache(file);
    const matchedFilters = [];
    for (const filter of filters) {
      if (this.filterMatchesFile(file, cache, filter)) {
        matchedFilters.push(filter);
      }
    }
    return matchedFilters;
  }
  async getMatchingFiles(magicFolder) {
    const filesWithFilters = await this.getMatchingFilesWithFilters(magicFolder);
    return filesWithFilters.map((f) => f.file);
  }
  fileHasTag(cache, tagValue) {
    var _a;
    if (!cache) return false;
    const normalizedSearch = tagValue.replace(/^#/, "").toLowerCase();
    if (cache.tags) {
      for (const tagObj of cache.tags) {
        const normalizedTag = tagObj.tag.replace(/^#/, "").toLowerCase();
        if (normalizedTag === normalizedSearch || normalizedTag.startsWith(normalizedSearch + "/")) {
          return true;
        }
      }
    }
    if ((_a = cache.frontmatter) == null ? void 0 : _a.tags) {
      const fmTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
      for (const tag of fmTags) {
        const normalizedTag = String(tag).replace(/^#/, "").toLowerCase();
        if (normalizedTag === normalizedSearch || normalizedTag.startsWith(normalizedSearch + "/")) {
          return true;
        }
      }
    }
    return false;
  }
  fileHasLink(cache, linkValue) {
    if (!(cache == null ? void 0 : cache.links)) return false;
    const normalizedSearch = linkValue.replace(/^\[\[|\]\]$/g, "").toLowerCase();
    for (const link of cache.links) {
      const normalizedLink = link.link.toLowerCase();
      if (normalizedLink === normalizedSearch || normalizedLink.includes(normalizedSearch)) {
        return true;
      }
    }
    return false;
  }
  fileHasFrontmatter(cache, key) {
    if (!(cache == null ? void 0 : cache.frontmatter)) return false;
    if (key.includes(":")) {
      const [fmKey, fmValue] = key.split(":").map((s) => s.trim());
      const value = cache.frontmatter[fmKey];
      if (value === void 0) return false;
      return String(value).toLowerCase().includes(fmValue.toLowerCase());
    }
    return cache.frontmatter[key] !== void 0;
  }
  matchString(value, pattern, operator) {
    const normalizedValue = value.toLowerCase();
    const normalizedPattern = pattern.toLowerCase();
    switch (operator) {
      case "equals":
        return normalizedValue === normalizedPattern;
      case "contains":
        return normalizedValue.includes(normalizedPattern);
      case "startsWith":
        return normalizedValue.startsWith(normalizedPattern);
      case "endsWith":
        return normalizedValue.endsWith(normalizedPattern);
      default:
        return normalizedValue.includes(normalizedPattern);
    }
  }
  sortFilesWithFilters(files, sortBy, sortOrder) {
    const sorted = [...files].sort((a, b) => {
      let comparison = 0;
      switch (sortBy) {
        case "name":
          comparison = a.file.basename.localeCompare(b.file.basename);
          break;
        case "modified":
          comparison = a.file.stat.mtime - b.file.stat.mtime;
          break;
        case "created":
          comparison = a.file.stat.ctime - b.file.stat.ctime;
          break;
        case "type":
          comparison = a.file.extension.localeCompare(b.file.extension);
          break;
        case "size":
          comparison = a.file.stat.size - b.file.stat.size;
          break;
        case "tags":
        case "tag":
          comparison = b.matchedFilters.length - a.matchedFilters.length;
          break;
      }
      return sortOrder === "asc" ? comparison : -comparison;
    });
    return sorted;
  }
  sortFiles(files, sortBy, sortOrder) {
    const sorted = [...files].sort((a, b) => {
      let comparison = 0;
      switch (sortBy) {
        case "name":
          comparison = a.basename.localeCompare(b.basename);
          break;
        case "modified":
          comparison = a.stat.mtime - b.stat.mtime;
          break;
        case "created":
          comparison = a.stat.ctime - b.stat.ctime;
          break;
        case "type":
          comparison = a.extension.localeCompare(b.extension);
          break;
        case "size":
          comparison = a.stat.size - b.stat.size;
          break;
        case "tags":
        case "tag":
          comparison = a.basename.localeCompare(b.basename);
          break;
      }
      return sortOrder === "asc" ? comparison : -comparison;
    });
    return sorted;
  }
  setupDragAndDrop(folderEl, titleEl, magicFolder) {
    titleEl.draggable = true;
    this.registerDomEvent(titleEl, "dragstart", (e) => {
      if (e.dataTransfer) {
        e.dataTransfer.setData("text/magic-folder-id", magicFolder.id);
        e.dataTransfer.effectAllowed = "move";
      }
      this.draggingMagicFolderId = magicFolder.id;
      folderEl.addClass("is-being-dragged");
    });
    this.registerDomEvent(titleEl, "dragend", () => {
      this.draggingMagicFolderId = null;
      folderEl.removeClass("is-being-dragged");
      document.querySelectorAll(".magic-drop-target").forEach((el) => el.removeClass("magic-drop-target"));
    });
    this.registerDomEvent(folderEl, "dragover", (e) => {
      var _a;
      const draggedId = ((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/magic-folder-id")) || this.draggingMagicFolderId;
      if (!draggedId || draggedId === magicFolder.id) return;
      e.preventDefault();
      folderEl.addClass("magic-drop-target");
    });
    this.registerDomEvent(folderEl, "dragleave", (e) => {
      const related = e.relatedTarget;
      if (related && folderEl.contains(related)) return;
      folderEl.removeClass("magic-drop-target");
    });
    this.registerDomEvent(folderEl, "drop", (e) => {
      var _a;
      e.preventDefault();
      folderEl.removeClass("magic-drop-target");
      document.querySelectorAll(".magic-drop-target").forEach((el) => el.removeClass("magic-drop-target"));
      const draggedId = ((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/magic-folder-id")) || this.draggingMagicFolderId;
      if (!draggedId || draggedId === magicFolder.id) return;
      const fromIdx = this.settings.magicFolders.findIndex((f) => f.id === draggedId);
      const toIdx = this.settings.magicFolders.findIndex((f) => f.id === magicFolder.id);
      if (fromIdx === -1 || toIdx === -1 || fromIdx === toIdx) return;
      const [moved] = this.settings.magicFolders.splice(fromIdx, 1);
      const insertIdx = fromIdx < toIdx ? toIdx - 1 : toIdx;
      this.settings.magicFolders.splice(insertIdx, 0, moved);
      this.draggingMagicFolderId = null;
      void this.saveSettings();
      void this.renderAllMagicFolders();
    });
  }
  attachMatchedFiltersTooltip(targetEl, matchedFilters) {
    if (!this.settings.showTooltips || matchedFilters.length === 0) return;
    const tooltip = document.createElement("div");
    tooltip.className = "magic-file-tags-tooltip magic-file-tags-tooltip--body";
    tooltip.style.position = "fixed";
    tooltip.style.zIndex = "999999";
    tooltip.style.opacity = "0";
    tooltip.style.visibility = "hidden";
    for (const filter of matchedFilters) {
      const pill = document.createElement("span");
      pill.className = "tag-pill";
      pill.textContent = this.formatFilterLabel(filter);
      tooltip.appendChild(pill);
    }
    document.body.appendChild(tooltip);
    this.tooltipElements.add(tooltip);
    this.tooltipTimers.set(tooltip, { show: null, hide: null });
    const positionTooltip = () => {
      const rect = targetEl.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();
      const margin = 8;
      const halfWidth = tooltipRect.width / 2;
      let x = rect.left + rect.width / 2;
      x = Math.max(margin + halfWidth, Math.min(x, window.innerWidth - margin - halfWidth));
      let y = rect.top - 8;
      const minY = margin + tooltipRect.height;
      if (y < minY) y = minY;
      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;
      tooltip.style.transform = "translateX(-50%) translateY(-100%)";
    };
    const timers = this.tooltipTimers.get(tooltip);
    const show = () => {
      positionTooltip();
      tooltip.classList.add("is-visible");
    };
    const hide = () => {
      tooltip.classList.remove("is-visible");
    };
    const scheduleShow = () => {
      if (!timers) return;
      if (timers.hide) window.clearTimeout(timers.hide);
      if (timers.show) window.clearTimeout(timers.show);
      timers.show = window.setTimeout(show, 60);
    };
    const scheduleHide = () => {
      if (!timers) return;
      if (timers.show) window.clearTimeout(timers.show);
      if (timers.hide) window.clearTimeout(timers.hide);
      timers.hide = window.setTimeout(hide, 80);
    };
    this.registerDomEvent(targetEl, "mouseenter", scheduleShow);
    this.registerDomEvent(targetEl, "mousemove", () => {
      if (tooltip.classList.contains("is-visible")) positionTooltip();
    });
    this.registerDomEvent(targetEl, "mouseleave", scheduleHide);
    this.registerDomEvent(targetEl, "mousedown", scheduleHide);
  }
  formatFilterLabel(filter) {
    switch (filter.type) {
      case "tag":
        return filter.value.startsWith("#") ? filter.value : `#${filter.value}`;
      case "link":
        return filter.value.startsWith("[[") ? filter.value : `[[${filter.value}]]`;
      case "extension":
        return filter.value.startsWith(".") ? filter.value : `.${filter.value}`;
      case "folder":
        return filter.value.startsWith("folder:") ? filter.value : `folder:${filter.value}`;
      case "frontmatter":
        return filter.value;
      default:
        return filter.value;
    }
  }
  normalizeMagicColor(colorValue) {
    if (!colorValue) {
      return { solid: "var(--text-accent)", bg: "var(--text-accent)" };
    }
    const rgba = String(colorValue).replace(/\s+/g, "").match(/^rgba?\((\d+),(\d+),(\d+)(?:,([0-9.]+))?\)$/i);
    if (rgba) {
      const r = Number(rgba[1]);
      const g = Number(rgba[2]);
      const b = Number(rgba[3]);
      const a = rgba[4] !== void 0 ? Number(rgba[4]) : 1;
      const solid = `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
      const bg = a < 1 ? `rgba(${r}, ${g}, ${b}, ${a})` : solid;
      return { solid, bg };
    }
    if (/^#([0-9a-f]{6})$/i.test(colorValue)) {
      return { solid: colorValue, bg: colorValue };
    }
    return { solid: "var(--text-accent)", bg: "var(--text-accent)" };
  }
  setMagicColorVars(el, colorValue) {
    if (!el) return;
    const normalized = this.normalizeMagicColor(colorValue);
    el.style.setProperty("--magic-folder-color", normalized.solid);
    el.style.setProperty("--magic-folder-color-bg", normalized.bg);
  }
  updateUnreadForFolder(magicFolder, currentPaths, previousPaths) {
    if (!Array.isArray(currentPaths)) return false;
    const hasPrev = Array.isArray(previousPaths);
    const prevSet = new Set(hasPrev ? previousPaths : []);
    const currentSet = new Set(currentPaths);
    const unread = new Set(magicFolder.unreadFilePaths || []);
    let changed = false;
    for (const p of Array.from(unread)) {
      if (!currentSet.has(p)) {
        unread.delete(p);
        changed = true;
      }
    }
    if (hasPrev) {
      for (const p of currentSet) {
        if (!prevSet.has(p)) {
          if (!unread.has(p)) {
            unread.add(p);
            changed = true;
          }
        }
      }
    }
    if (changed) {
      magicFolder.unreadFilePaths = Array.from(unread);
    }
    return changed;
  }
  markFileAsRead(filePath) {
    if (!this.settings.highlightUnreadFiles && !this.settings.showNewItemsBadge) return;
    let changed = false;
    for (const folder of this.settings.magicFolders) {
      if (!folder.unreadFilePaths || folder.unreadFilePaths.length === 0) continue;
      if (!folder.unreadFilePaths.includes(filePath)) continue;
      folder.unreadFilePaths = folder.unreadFilePaths.filter((p) => p !== filePath);
      changed = true;
      this.updateUnreadBadgeInDom(folder.id);
      this.removeUnreadClassInDom(folder.id, filePath);
    }
    if (changed) {
      void this.saveSettings();
    }
  }
  markFileAsReadInMagicFolder(folderId, filePath) {
    const folder = this.settings.magicFolders.find((f) => f.id === folderId);
    if (!folder || !Array.isArray(folder.unreadFilePaths) || folder.unreadFilePaths.length === 0) return;
    if (!folder.unreadFilePaths.includes(filePath)) return;
    folder.unreadFilePaths = folder.unreadFilePaths.filter((p) => p !== filePath);
    this.updateUnreadBadgeInDom(folder.id);
    this.removeUnreadClassInDom(folder.id, filePath);
    void this.saveSettings();
  }
  markFileAsUnreadInMagicFolder(folderId, filePath) {
    const folder = this.settings.magicFolders.find((f) => f.id === folderId);
    if (!folder) return;
    const unread = new Set(folder.unreadFilePaths || []);
    if (unread.has(filePath)) return;
    unread.add(filePath);
    folder.unreadFilePaths = Array.from(unread);
    this.updateUnreadBadgeInDom(folder.id);
    this.addUnreadClassInDom(folder.id, filePath);
    void this.saveSettings();
  }
  updateUnreadBadgeInDom(folderId) {
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (!folderEl) return;
    const titleEl = folderEl.querySelector(".nav-folder-title");
    if (!titleEl) return;
    const badge = titleEl.querySelector(".magic-folder-new-badge");
    if (!badge) return;
    const folder = this.settings.magicFolders.find((f) => f.id === folderId);
    const unreadCount = (folder == null ? void 0 : folder.unreadFilePaths) ? folder.unreadFilePaths.length : 0;
    if (!this.settings.showNewItemsBadge || !folder || unreadCount === 0) {
      badge.textContent = "";
      badge.addClass("is-hidden");
      return;
    }
    badge.textContent = String(unreadCount);
    badge.removeClass("is-hidden");
  }
  // --- NOUVELLES METHODES DE MISE A JOUR TEMPS REEL ---
  updateFolderNameInDom(folderId, newName) {
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (!folderEl) return;
    const titleContent = folderEl.querySelector(".nav-folder-title-content");
    if (titleContent) {
      titleContent.textContent = newName;
    }
  }
  updateColorInDom(folderId, color) {
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (folderEl) {
      this.setMagicColorVars(folderEl, color);
    }
    const fileEls = document.querySelectorAll(`.magic-folder-item[data-magic-folder-id="${folderId}"] .nav-file`);
    fileEls.forEach((fileEl) => {
      if (fileEl instanceof HTMLElement) {
        this.setMagicColorVars(fileEl, color);
      }
    });
  }
  updateIconTypeInDom(folderId, type, value) {
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (!folderEl) return;
    const iconWrap = folderEl.querySelector(".magic-folder-icon");
    if (!iconWrap) return;
    iconWrap.innerHTML = "";
    iconWrap.style.transform = "";
    if (type === "custom") {
      const img = document.createElement("img");
      img.className = "magic-folder-custom-icon";
      img.src = value;
      iconWrap.appendChild(img);
    } else if (type === "emoji") {
      iconWrap.textContent = value;
    } else {
      (0, import_obsidian.setIcon)(iconWrap, value);
    }
  }
  updateIconStyleInDom(folderId, size, x, y) {
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (!folderEl) return;
    const iconWrap = folderEl.querySelector(".magic-folder-icon");
    if (!iconWrap) return;
    const img = iconWrap.querySelector("img.magic-folder-custom-icon");
    const svg = iconWrap.querySelector("svg");
    if (img) {
      img.style.height = `${size}px`;
      img.style.transform = `translate(${x}px, ${y}px)`;
    } else if (svg) {
      svg.style.width = `${size}px`;
      svg.style.height = `${size}px`;
      svg.style.transform = `translate(${x}px, ${y}px)`;
    } else {
      iconWrap.style.fontSize = `${size}px`;
      iconWrap.style.display = "inline-block";
      iconWrap.style.transform = `translate(${x}px, ${y}px)`;
    }
  }
  // --- FIN NOUVELLES METHODES ---
  updateCustomIconSizeInDom(folderId, size) {
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (!folderEl) return;
    const img = folderEl.querySelector(".magic-folder-icon img.magic-folder-custom-icon");
    if (!img) return;
    img.style.height = `${size}px`;
    const folder = this.settings.magicFolders.find((f) => f.id === folderId);
    const keepRatio = folder ? folder.customIconKeepRatio : false;
    img.style.width = keepRatio ? "auto" : `${size}px`;
    const offsetX = folder ? folder.customIconOffsetX || 0 : 0;
    const offsetY = folder ? folder.customIconOffsetY || 0 : 0;
    img.style.transform = offsetX !== 0 || offsetY !== 0 ? `translate(${offsetX}px, ${offsetY}px)` : "";
  }
  updateCustomIconInDom(folderId, dataUrl) {
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (!folderEl) return;
    const iconWrap = folderEl.querySelector(".magic-folder-icon");
    if (!iconWrap) return;
    let img = iconWrap.querySelector("img.magic-folder-custom-icon");
    if (!img) {
      iconWrap.textContent = "";
      img = document.createElement("img");
      img.className = "magic-folder-custom-icon";
      iconWrap.appendChild(img);
    }
    const folder = this.settings.magicFolders.find((f) => f.id === folderId);
    const size = folder ? folder.customIconSize || 28 : 28;
    const keepRatio = folder ? folder.customIconKeepRatio : false;
    const offsetX = folder ? folder.customIconOffsetX || 0 : 0;
    const offsetY = folder ? folder.customIconOffsetY || 0 : 0;
    img.src = dataUrl;
    img.style.height = `${size}px`;
    img.style.width = keepRatio ? "auto" : `${size}px`;
    img.style.transform = offsetX !== 0 || offsetY !== 0 ? `translate(${offsetX}px, ${offsetY}px)` : "";
  }
  updateHideNameInDom(folderId, hide) {
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (!folderEl) return;
    if (hide) {
      folderEl.addClass("magic-folder-icon-only");
    } else {
      folderEl.removeClass("magic-folder-icon-only");
    }
    const titleContent = folderEl.querySelector(".nav-folder-title-content");
    if (titleContent) {
      if (hide) {
        titleContent.style.setProperty("display", "none", "important");
      } else {
        titleContent.style.removeProperty("display");
      }
    }
  }
  removeUnreadClassInDom(folderId, filePath) {
    if (!this.settings.highlightUnreadFiles) return;
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (!folderEl) return;
    const titleEl = folderEl.querySelector(`.nav-file-title[data-path="${CSS.escape(filePath)}"]`);
    if (!titleEl) return;
    const fileEl = titleEl.closest(".nav-file");
    if (fileEl) fileEl.removeClass("magic-file-new");
  }
  addUnreadClassInDom(folderId, filePath) {
    if (!this.settings.highlightUnreadFiles) return;
    const folderEl = document.querySelector(`[data-magic-folder-id="${folderId}"]`);
    if (!folderEl) return;
    const titleEl = folderEl.querySelector(`.nav-file-title[data-path="${CSS.escape(filePath)}"]`);
    if (!titleEl) return;
    const fileEl = titleEl.closest(".nav-file");
    if (fileEl) fileEl.addClass("magic-file-new");
  }
  isExternalPath(filePath) {
    return /^[a-zA-Z]:[\\/]/.test(filePath) || filePath.startsWith("\\\\") || filePath.startsWith("/");
  }
  getVaultBasePath() {
    const adapter = this.app.vault.adapter;
    if (adapter && typeof adapter.getBasePath === "function") {
      return adapter.getBasePath();
    }
    if (adapter && adapter.basePath) {
      return adapter.basePath;
    }
    return process.cwd();
  }
  getCustomIconStorageDir() {
    return path.join(this.getVaultBasePath(), ".obsidian", "plugins", "obsidian-magic-folders", "custom-icons");
  }
  getCustomIconStoragePath(folderId, ext = ".png") {
    const safeExt = ext.startsWith(".") ? ext : `.${ext}`;
    return path.join(this.getCustomIconStorageDir(), `${folderId}${safeExt}`);
  }
  setCustomIconCache(iconPath, resource) {
    if (!iconPath || !resource) return;
    this.customIconResourceCache.set(iconPath, resource);
  }
  getLocalStorageCacheKey(iconPath) {
    return `${this.customIconLocalStorageKeyPrefix}${iconPath}`;
  }
  getCachedIconFromLocalStorage(iconPath) {
    try {
      const key = this.getLocalStorageCacheKey(iconPath);
      const value = window.localStorage.getItem(key);
      return value || null;
    } catch (err) {
      return null;
    }
  }
  setCachedIconToLocalStorage(iconPath, resource) {
    try {
      if (!resource || resource.length > 9e5) return;
      const key = this.getLocalStorageCacheKey(iconPath);
      window.localStorage.setItem(key, resource);
    } catch (err) {
    }
  }
  loadIconIntoImg(iconPath, img) {
    if (!iconPath || !img) return;
    const cached = this.customIconResourceCache.get(iconPath);
    if (cached) {
      img.src = cached;
      img.classList.remove("is-loading");
      return;
    }
    const lsCached = this.getCachedIconFromLocalStorage(iconPath);
    if (lsCached) {
      this.customIconResourceCache.set(iconPath, lsCached);
      img.src = lsCached;
      img.classList.remove("is-loading");
      return;
    }
    const load = async () => {
      const resource = await this.readFileAsDataUrl(iconPath);
      if (!resource) return;
      this.customIconResourceCache.set(iconPath, resource);
      this.setCachedIconToLocalStorage(iconPath, resource);
      img.src = resource;
      img.classList.remove("is-loading");
    };
    if ("requestIdleCallback" in window) {
      window.requestIdleCallback(() => void load(), { timeout: 500 });
    } else {
      setTimeout(() => void load(), 0);
    }
  }
  ensureCustomIconDir() {
    const dir = this.getCustomIconStorageDir();
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }
  getIconMimeType(iconPath) {
    const ext = path.extname(iconPath).toLowerCase();
    switch (ext) {
      case ".svg":
        return "image/svg+xml";
      case ".png":
        return "image/png";
      case ".jpg":
      case ".jpeg":
        return "image/jpeg";
      case ".gif":
        return "image/gif";
      case ".webp":
        return "image/webp";
      default:
        return "application/octet-stream";
    }
  }
  async readFileAsDataUrl(iconPath) {
    try {
      const mime = this.getIconMimeType(iconPath);
      if (this.isExternalPath(iconPath)) {
        if (!fs.existsSync(iconPath)) return null;
        if (mime === "image/svg+xml") {
          const svgText = fs.readFileSync(iconPath, "utf8");
          return `data:${mime};utf8,${encodeURIComponent(svgText)}`;
        }
        const buffer2 = fs.readFileSync(iconPath);
        return `data:${mime};base64,${buffer2.toString("base64")}`;
      }
      if (mime === "image/svg+xml") {
        const svgText = await this.app.vault.adapter.read(iconPath);
        return `data:${mime};utf8,${encodeURIComponent(svgText)}`;
      }
      const buffer = await this.app.vault.adapter.readBinary(iconPath);
      const b64 = Buffer.from(buffer).toString("base64");
      return `data:${mime};base64,${b64}`;
    } catch (err) {
      return null;
    }
  }
  async resizeIconToPng(iconPath, size, keepRatio) {
    const dataUrl = await this.readFileAsDataUrl(iconPath);
    if (!dataUrl) return null;
    return await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        let width = size;
        let height = size;
        if (keepRatio && img.naturalHeight > 0) {
          height = size;
          width = Math.max(1, Math.round(img.naturalWidth * (height / img.naturalHeight)));
        }
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          resolve(null);
          return;
        }
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(img, 0, 0, width, height);
        resolve(canvas.toDataURL("image/png"));
      };
      img.onerror = () => resolve(null);
      img.src = dataUrl;
    });
  }
  async saveCustomIconForFolder(folderId, sourcePath, size, keepRatio) {
    try {
      this.ensureCustomIconDir();
      const ext = path.extname(sourcePath).toLowerCase();
      if (ext === ".gif") {
        const filePath2 = this.getCustomIconStoragePath(folderId, ".gif");
        if (this.isExternalPath(sourcePath)) {
          const buffer = fs.readFileSync(sourcePath);
          fs.writeFileSync(filePath2, buffer);
        } else {
          const buffer = await this.app.vault.adapter.readBinary(sourcePath);
          fs.writeFileSync(filePath2, Buffer.from(buffer));
        }
        const previewDataUrl = await this.readFileAsDataUrl(filePath2);
        if (previewDataUrl) this.setCustomIconCache(filePath2, previewDataUrl);
        return { filePath: filePath2, previewDataUrl: previewDataUrl || "" };
      }
      const pngDataUrl = await this.resizeIconToPng(sourcePath, size, keepRatio);
      if (!pngDataUrl) return null;
      const base64 = pngDataUrl.split(",")[1];
      const filePath = this.getCustomIconStoragePath(folderId);
      fs.writeFileSync(filePath, Buffer.from(base64, "base64"));
      this.setCustomIconCache(filePath, pngDataUrl);
      return { filePath, previewDataUrl: pngDataUrl };
    } catch (err) {
      return null;
    }
  }
  getCustomIconResource(iconPath) {
    if (!iconPath) return null;
    const cached = this.customIconResourceCache.get(iconPath);
    if (cached) return cached;
    if (this.isExternalPath(iconPath)) {
      try {
        if (!fs.existsSync(iconPath)) return null;
        const mime = this.getIconMimeType(iconPath);
        if (mime === "image/svg+xml") {
          const svgText = fs.readFileSync(iconPath, "utf8");
          const resource2 = `data:${mime};utf8,${encodeURIComponent(svgText)}`;
          this.customIconResourceCache.set(iconPath, resource2);
          return resource2;
        }
        const buffer = fs.readFileSync(iconPath);
        const resource = `data:${mime};base64,${buffer.toString("base64")}`;
        this.customIconResourceCache.set(iconPath, resource);
        return resource;
      } catch (err) {
        return null;
      }
      return null;
    }
    const iconFile = this.app.vault.getAbstractFileByPath(iconPath);
    if (iconFile instanceof import_obsidian.TFile) {
      const resource = this.app.vault.getResourcePath(iconFile);
      this.customIconResourceCache.set(iconPath, resource);
      return resource;
    }
    return null;
  }
  getNewItemsCount(magicFolder) {
    if (!this.settings.showNewItemsBadge) return 0;
    if (!magicFolder.collapsed) return 0;
    return (magicFolder.unreadFilePaths || []).length;
  }
  showMagicFileContextMenu(e, filePath, matchedFilters, folderName, folderId) {
    const menu = new import_obsidian.Menu();
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      menu.addItem((item) => {
        item.setTitle(this.t("menu_open_source")).setIcon("file").onClick(() => {
          this.app.workspace.openLinkText(file.path, "", false);
        });
      });
      menu.addItem((item) => {
        item.setTitle(this.t("menu_open_new_tab")).setIcon("file-plus").onClick(() => {
          this.app.workspace.openLinkText(file.path, "", true);
        });
      });
    }
    if (folderId) {
      const folder = this.settings.magicFolders.find((f) => f.id === folderId);
      if (folder) {
        const unread = (folder.unreadFilePaths || []).includes(filePath);
        menu.addSeparator();
        menu.addItem((item) => {
          item.setTitle(this.t("menu_mark_read")).setIcon("check-circle-2").setDisabled(!unread).onClick(() => this.markFileAsReadInMagicFolder(folderId, filePath));
        });
        menu.addItem((item) => {
          item.setTitle(this.t("menu_mark_unread")).setIcon("circle").setDisabled(unread).onClick(() => this.markFileAsUnreadInMagicFolder(folderId, filePath));
        });
      }
    }
    if (folderName || matchedFilters.length > 0) {
      menu.addSeparator();
      if (folderName) {
        menu.addItem((item) => {
          item.setTitle(this.t("menu_in_magic_folder", { name: folderName })).setIcon("sparkles").setDisabled(true);
        });
      }
      if (matchedFilters.length > 0) {
        const filterText = matchedFilters.map((f) => this.formatFilterLabel(f)).join(", ");
        menu.addItem((item) => {
          item.setTitle(this.t("menu_matched", { filters: filterText })).setIcon("tag").setDisabled(true);
        });
      }
    }
    menu.showAtMouseEvent(e);
  }
  createMagicFolderDOM(magicFolder, filesWithFilters) {
    const folderEl = document.createElement("div");
    folderEl.className = "tree-item nav-folder magic-folder-item";
    this.setMagicColorVars(folderEl, magicFolder.color);
    folderEl.setAttribute("data-magic-folder-id", magicFolder.id);
    if (magicFolder.collapsed) {
      folderEl.addClass("is-collapsed");
    }
    const titleEl = document.createElement("div");
    titleEl.className = "tree-item-self is-clickable mod-collapsible nav-folder-title";
    titleEl.setAttribute("data-magic-folder-id", magicFolder.id);
    const collapseIcon = document.createElement("div");
    collapseIcon.className = `tree-item-icon collapse-icon nav-folder-collapse-indicator ${magicFolder.collapsed ? "is-collapsed" : ""}`;
    (0, import_obsidian.setIcon)(collapseIcon, "right-triangle");
    titleEl.appendChild(collapseIcon);
    const magicIcon = document.createElement("span");
    magicIcon.className = "magic-folder-icon";
    const offsetX = magicFolder.customIconOffsetX || 0;
    const offsetY = magicFolder.customIconOffsetY || 0;
    const size = magicFolder.customIconSize || 28;
    if (magicFolder.customIconPath) {
      const resourcePath = this.getCustomIconResource(magicFolder.customIconPath);
      if (resourcePath) {
        const img = document.createElement("img");
        img.className = "magic-folder-custom-icon";
        img.src = resourcePath;
        img.loading = "eager";
        img.decoding = "async";
        img.style.height = `${size}px`;
        img.style.width = magicFolder.customIconKeepRatio ? "auto" : `${size}px`;
        if (offsetX !== 0 || offsetY !== 0) {
          img.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
        magicIcon.appendChild(img);
      } else if (magicFolder.emoji) {
        magicIcon.textContent = magicFolder.emoji;
        magicIcon.style.fontSize = `${size}px`;
        magicIcon.style.display = "inline-block";
        if (offsetX !== 0 || offsetY !== 0) {
          magicIcon.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
      } else {
        (0, import_obsidian.setIcon)(magicIcon, magicFolder.icon);
        const svg = magicIcon.querySelector("svg");
        if (svg) {
          svg.style.width = `${size}px`;
          svg.style.height = `${size}px`;
          if (offsetX !== 0 || offsetY !== 0) {
            svg.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
          }
        }
      }
    } else if (magicFolder.emoji) {
      magicIcon.textContent = magicFolder.emoji;
      magicIcon.style.fontSize = `${size}px`;
      magicIcon.style.display = "inline-block";
      if (offsetX !== 0 || offsetY !== 0) {
        magicIcon.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      }
    } else {
      (0, import_obsidian.setIcon)(magicIcon, magicFolder.icon);
      const svg = magicIcon.querySelector("svg");
      if (svg) {
        svg.style.width = `${size}px`;
        svg.style.height = `${size}px`;
        if (offsetX !== 0 || offsetY !== 0) {
          svg.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
      }
    }
    titleEl.appendChild(magicIcon);
    const titleContent = document.createElement("div");
    titleContent.className = "tree-item-inner nav-folder-title-content";
    titleContent.textContent = magicFolder.name;
    titleEl.appendChild(titleContent);
    if (this.settings.showFileCount) {
      const countBadge = document.createElement("span");
      countBadge.className = "magic-file-count";
      countBadge.textContent = String(filesWithFilters.length);
      titleEl.appendChild(countBadge);
    }
    const newBadge = document.createElement("span");
    newBadge.className = "magic-folder-new-badge";
    const newCount = this.getNewItemsCount(magicFolder);
    if (newCount > 0) {
      newBadge.textContent = String(newCount);
    } else {
      newBadge.addClass("is-hidden");
    }
    titleEl.appendChild(newBadge);
    folderEl.appendChild(titleEl);
    if (magicFolder.hideName) {
      folderEl.addClass("magic-folder-icon-only");
      titleContent.style.setProperty("display", "none", "important");
    } else {
      titleContent.style.removeProperty("display");
    }
    this.setupDragAndDrop(folderEl, titleEl, magicFolder);
    const childrenEl = document.createElement("div");
    childrenEl.className = "tree-item-children nav-folder-children";
    childrenEl.style.display = magicFolder.collapsed ? "none" : "block";
    const unreadSet = this.settings.highlightUnreadFiles && Array.isArray(magicFolder.unreadFilePaths) ? new Set(magicFolder.unreadFilePaths) : null;
    for (const fileWithFilters of filesWithFilters) {
      const isNew = unreadSet ? unreadSet.has(fileWithFilters.file.path) : false;
      const fileEl = this.createFileDOM(fileWithFilters.file, fileWithFilters.matchedFilters, magicFolder.color, isNew, magicFolder.id, magicFolder.name);
      childrenEl.appendChild(fileEl);
    }
    folderEl.appendChild(childrenEl);
    this.registerDomEvent(titleEl, "click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      const isCollapsed = folderEl.hasClass("is-collapsed");
      if (isCollapsed) {
        folderEl.removeClass("is-collapsed");
        collapseIcon.removeClass("is-collapsed");
        childrenEl.style.display = "block";
      } else {
        folderEl.addClass("is-collapsed");
        collapseIcon.addClass("is-collapsed");
        childrenEl.style.display = "none";
      }
      if (isCollapsed) {
        this.updateUnreadBadgeInDom(magicFolder.id);
      }
      const folder = this.settings.magicFolders.find((f) => f.id === magicFolder.id);
      if (folder) {
        folder.collapsed = !isCollapsed;
        this.saveSettings();
        this.updateUnreadBadgeInDom(magicFolder.id);
      }
    });
    this.registerDomEvent(titleEl, "contextmenu", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.showMagicFolderContextMenu(e, magicFolder);
    });
    return folderEl;
  }
  createFileDOM(file, matchedFilters, folderColor, isNew, folderId, folderName) {
    const fileEl = document.createElement("div");
    fileEl.className = "tree-item nav-file";
    if (isNew) fileEl.addClass("magic-file-new");
    this.setMagicColorVars(fileEl, folderColor);
    const titleEl = document.createElement("div");
    titleEl.className = "tree-item-self is-clickable nav-file-title";
    titleEl.setAttribute("data-path", file.path);
    titleEl.draggable = true;
    const titleContent = document.createElement("div");
    titleContent.className = "tree-item-inner nav-file-title-content";
    titleContent.textContent = file.basename;
    titleEl.appendChild(titleContent);
    const extEl = document.createElement("span");
    extEl.className = "nav-file-tag";
    extEl.textContent = file.extension;
    titleEl.appendChild(extEl);
    fileEl.appendChild(titleEl);
    this.attachMatchedFiltersTooltip(titleEl, matchedFilters);
    this.registerDomEvent(titleEl, "click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      const explorer = this.getFileExplorer();
      const blockDurationMs = 4e3;
      this._lastMagicActiveTitleEl = titleEl;
      this.setMagicFileActive(titleEl);
      this.keepMagicFileActive(titleEl, blockDurationMs);
      this.blockRevealInFolder(explorer);
      try {
        await this.app.workspace.openLinkText(file.path, "", e.ctrlKey || e.metaKey);
      } finally {
        setTimeout(() => {
          this.keepMagicFileActive(titleEl, 600);
          this.unblockRevealInFolder(explorer);
        }, blockDurationMs);
      }
    });
    this.registerDomEvent(titleEl, "contextmenu", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.showMagicFileContextMenu(e, file.path, matchedFilters, folderName, folderId);
    });
    return fileEl;
  }
  showMagicFolderContextMenu(e, magicFolder) {
    const menu = new import_obsidian.Menu();
    const folderIndex = this.settings.magicFolders.findIndex((f) => f.id === magicFolder.id);
    menu.addItem((item) => {
      item.setTitle("\u2728 Do Magic (Edit Filters)").setIcon("wand-2").onClick(() => {
        this.openDoMagicModal(magicFolder);
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(this.t("menu_edit")).setIcon("pencil").onClick(() => {
        this.openEditMagicFolderModal(magicFolder);
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(this.t("menu_move_up")).setIcon("chevron-up").setDisabled(folderIndex <= 0).onClick(() => {
        if (folderIndex <= 0) return;
        const [moved] = this.settings.magicFolders.splice(folderIndex, 1);
        this.settings.magicFolders.splice(folderIndex - 1, 0, moved);
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_move_down")).setIcon("chevron-down").setDisabled(folderIndex === -1 || folderIndex >= this.settings.magicFolders.length - 1).onClick(() => {
        if (folderIndex === -1 || folderIndex >= this.settings.magicFolders.length - 1) return;
        const [moved] = this.settings.magicFolders.splice(folderIndex, 1);
        this.settings.magicFolders.splice(folderIndex + 1, 0, moved);
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(this.t("menu_sort_name")).setIcon(magicFolder.sortBy === "name" ? "check" : "").onClick(() => {
        magicFolder.sortBy = "name";
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_sort_modified")).setIcon(magicFolder.sortBy === "modified" ? "check" : "").onClick(() => {
        magicFolder.sortBy = "modified";
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_sort_created")).setIcon(magicFolder.sortBy === "created" ? "check" : "").onClick(() => {
        magicFolder.sortBy = "created";
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_sort_type")).setIcon(magicFolder.sortBy === "type" ? "check" : "").onClick(() => {
        magicFolder.sortBy = "type";
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_sort_size")).setIcon(magicFolder.sortBy === "size" ? "check" : "").onClick(() => {
        magicFolder.sortBy = "size";
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_sort_tag")).setIcon(magicFolder.sortBy === "tag" ? "check" : "").onClick(() => {
        magicFolder.sortBy = "tag";
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_order_asc")).setIcon(magicFolder.sortOrder === "asc" ? "check" : "").onClick(() => {
        magicFolder.sortOrder = "asc";
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_order_desc")).setIcon(magicFolder.sortOrder === "desc" ? "check" : "").onClick(() => {
        magicFolder.sortOrder = "desc";
        this.saveSettings();
        this.renderAllMagicFolders();
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_refresh")).setIcon("refresh-cw").onClick(() => {
        this.renderAllMagicFolders();
        new import_obsidian.Notice(this.t("notice_refresh", { name: magicFolder.name }));
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_mark_all_read")).setIcon("check-circle-2").onClick(async () => {
        magicFolder.unreadFilePaths = [];
        await this.saveSettings();
        this.renderAllMagicFolders();
        new import_obsidian.Notice(this.t("notice_marked_all_read", { name: magicFolder.name }));
      });
    });
    menu.addItem((item) => {
      item.setTitle(this.t("menu_mark_all_unread")).setIcon("circle").onClick(async () => {
        const filesWithFilters = await this.getMatchingFilesWithFilters(magicFolder);
        magicFolder.unreadFilePaths = filesWithFilters.map((f) => f.file.path);
        await this.saveSettings();
        this.renderAllMagicFolders();
        new import_obsidian.Notice(this.t("notice_marked_all_unread", { name: magicFolder.name }));
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(this.t("menu_delete")).setIcon("trash-2").onClick(() => {
        this.deleteMagicFolder(magicFolder.id);
      });
    });
    menu.showAtMouseEvent(e);
  }
  openCreateMagicFolderModal() {
    new MagicFolderModal(this.app, this, null).open();
  }
  openEditMagicFolderModal(magicFolder) {
    new MagicFolderModal(this.app, this, magicFolder).open();
  }
  openDoMagicModal(magicFolder) {
    new DoMagicModal(this.app, this, magicFolder).open();
  }
  async createMagicFolder(folder) {
    this.settings.magicFolders.push(folder);
    await this.saveSettings();
    await this.renderAllMagicFolders();
    new import_obsidian.Notice(this.t("notice_created", { name: folder.name }));
  }
  async updateMagicFolder(folder) {
    const index = this.settings.magicFolders.findIndex((f) => f.id === folder.id);
    if (index !== -1) {
      this.settings.magicFolders[index] = { ...folder };
      await this.saveSettings();
      await this.renderAllMagicFolders();
      new import_obsidian.Notice(this.t("notice_updated", { name: folder.name }));
    }
  }
  async deleteMagicFolder(id) {
    const folder = this.settings.magicFolders.find((f) => f.id === id);
    this.settings.magicFolders = this.settings.magicFolders.filter((f) => f.id !== id);
    await this.saveSettings();
    await this.renderAllMagicFolders();
    new import_obsidian.Notice(`Magic Folder "${folder == null ? void 0 : folder.name}" deleted!`);
  }
  getAllFolders() {
    const folders = [""];
    const allFolders = this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian.TFolder).map((f) => f.path).sort();
    return [...folders, ...allFolders];
  }
};
var MagicFolderModal = class extends import_obsidian.Modal {
  constructor(app, plugin, existingFolder) {
    var _a, _b, _c;
    super(app);
    this.domEventCleanup = [];
    this.plugin = plugin;
    this.isNew = !existingFolder;
    const nameHidden = existingFolder ? existingFolder.hideName !== void 0 ? existingFolder.hideName : existingFolder.hideCustomIconName || false : false;
    this.folder = existingFolder ? {
      ...existingFolder,
      filters: [...existingFolder.filters],
      customIconPath: existingFolder.customIconPath,
      customIconOffsetX: (_a = existingFolder.customIconOffsetX) != null ? _a : 0,
      customIconOffsetY: (_b = existingFolder.customIconOffsetY) != null ? _b : 0,
      customIconSize: (_c = existingFolder.customIconSize) != null ? _c : 28,
      hideCustomIconName: nameHidden,
      hideName: nameHidden
      // Synchronisation force
    } : {
      id: this.generateId(),
      name: this.plugin.t("modal_default_name"),
      icon: "wand-2",
      color: "#9b59b6",
      filters: [],
      sortBy: "name",
      sortOrder: "asc",
      collapsed: false,
      customIconOffsetX: 0,
      customIconOffsetY: 0,
      customIconSize: 28,
      hideCustomIconName: false,
      hideName: false
    };
    this.domEventCleanup = [];
  }
  generateId() {
    return "magic-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
  }
  onOpen() {
    var _a, _b, _c;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("magic-folder-modal");
    this.modalEl.addClass("magic-folder-modal");
    if (!this.isNew) {
      document.body.classList.add("magic-folder-edit-modal-open");
    }
    const t = this.plugin.t.bind(this.plugin);
    contentEl.createEl("h2", { text: this.isNew ? t("modal_create_title") : t("modal_edit_title") });
    let emojiGrid = null;
    new import_obsidian.Setting(contentEl).setName(t("modal_name_label")).setDesc(t("modal_name_desc")).addText((text) => {
      text.setValue(this.folder.name).setPlaceholder(t("modal_name_placeholder")).onChange((value) => {
        this.folder.name = value;
        if (!this.isNew) this.plugin.updateFolderNameInDom(this.folder.id, value);
      });
    });
    new import_obsidian.Setting(contentEl).setName("Hide name (Icon only)").setDesc("Show only the icon in the sidebar.").addToggle((toggle) => {
      toggle.setValue(!!this.folder.hideName).onChange((value) => {
        this.folder.hideName = value;
        this.folder.hideCustomIconName = value;
        this.plugin.updateHideNameInDom(this.folder.id, value);
        if (!this.isNew) {
          const liveFolder = this.plugin.settings.magicFolders.find((f) => f.id === this.folder.id);
          if (liveFolder) {
            liveFolder.hideName = value;
            liveFolder.hideCustomIconName = value;
          }
        }
      });
    });
    const colorSetting = new import_obsidian.Setting(contentEl).setName(t("modal_color_label")).setDesc(t("modal_color_desc"));
    const colorContainer = colorSetting.controlEl.createDiv("color-picker-container");
    const colorInput = colorSetting.controlEl.createEl("input", { type: "color" });
    colorInput.className = "magic-folder-color-input";
    const parseColor = (value) => {
      if (!value) return { hex: "#9b59b6", alpha: 100 };
      const rgba = value.replace(/\s+/g, "").match(/^rgba?\((\d+),(\d+),(\d+)(?:,([0-9.]+))?\)$/i);
      if (rgba) {
        const r = Number(rgba[1]).toString(16).padStart(2, "0");
        const g = Number(rgba[2]).toString(16).padStart(2, "0");
        const b = Number(rgba[3]).toString(16).padStart(2, "0");
        const a = rgba[4] !== void 0 ? Math.round(Number(rgba[4]) * 100) : 100;
        return { hex: `#${r}${g}${b}`, alpha: Math.min(100, Math.max(0, a)) };
      }
      if (/^#([0-9a-f]{6})$/i.test(value)) {
        return { hex: value, alpha: 100 };
      }
      return { hex: "#9b59b6", alpha: 100 };
    };
    const applyColor = (hex, alpha) => {
      const a = Math.min(100, Math.max(0, alpha));
      const newColor = a === 100 ? hex : `rgba(${parseInt(hex.slice(1, 3), 16)}, ${parseInt(hex.slice(3, 5), 16)}, ${parseInt(hex.slice(5, 7), 16)}, ${a / 100})`;
      this.folder.color = newColor;
      if (!this.isNew) this.plugin.updateColorInDom(this.folder.id, newColor);
    };
    const initial = parseColor(this.folder.color);
    colorInput.value = initial.hex;
    for (const color of PRESET_COLORS) {
      const swatch = colorContainer.createDiv("color-swatch");
      swatch.style.backgroundColor = color;
      if (this.folder.color === color) swatch.addClass("selected");
      swatch.addEventListener("click", () => {
        colorContainer.querySelectorAll(".color-swatch").forEach((s) => s.removeClass("selected"));
        swatch.addClass("selected");
        colorInput.value = color;
        applyColor(color, opacityInput ? Number(opacityInput.value) : 100);
      });
    }
    colorInput.addEventListener("input", () => {
      applyColor(colorInput.value, opacityInput ? Number(opacityInput.value) : 100);
      colorContainer.querySelectorAll(".color-swatch").forEach((s) => s.removeClass("selected"));
    });
    const opacityWrap = colorSetting.controlEl.createDiv({ cls: "magic-folder-color-opacity" });
    opacityWrap.createEl("span", { text: "Opacity" });
    const opacityInput = opacityWrap.createEl("input", { type: "range", min: "0", max: "100", step: "1" });
    const opacityValue = opacityWrap.createEl("span", { text: `${initial.alpha}%` });
    opacityInput.value = String(initial.alpha);
    opacityInput.addEventListener("input", () => {
      opacityValue.textContent = `${opacityInput.value}%`;
      applyColor(colorInput.value, Number(opacityInput.value));
    });
    const iconSetting = new import_obsidian.Setting(contentEl).setName(t("modal_icon_label")).setDesc(t("modal_icon_desc"));
    const iconContainer = iconSetting.controlEl.createDiv("icon-picker-container");
    let customIconContainer = null;
    let customIconPreview = null;
    let customIconSizeValue = null;
    let customIconSlider = null;
    const clearCustomIconSelection = () => {
      if (customIconContainer) {
        customIconContainer.querySelectorAll(".custom-icon-btn").forEach((btn) => btn.classList.remove("selected"));
      }
    };
    const clearIconSelection = () => {
      iconContainer.querySelectorAll(".icon-option").forEach((i) => i.removeClass("selected"));
    };
    for (const icon of AVAILABLE_ICONS) {
      const iconOption = iconContainer.createDiv("icon-option");
      (0, import_obsidian.setIcon)(iconOption, icon);
      if (this.folder.icon === icon) iconOption.addClass("selected");
      iconOption.addEventListener("click", () => {
        clearIconSelection();
        iconOption.addClass("selected");
        this.folder.icon = icon;
        this.folder.emoji = void 0;
        this.folder.customIconPath = void 0;
        clearCustomIconSelection();
        if (emojiGrid) {
          emojiGrid.querySelectorAll(".emoji-btn").forEach((btn) => btn.classList.remove("selected"));
        }
        if (!this.isNew) this.plugin.updateIconTypeInDom(this.folder.id, "icon", icon);
        if (!this.isNew) this.plugin.updateIconStyleInDom(this.folder.id, this.folder.customIconSize || 28, this.folder.customIconOffsetX || 0, this.folder.customIconOffsetY || 0);
      });
    }
    const emojiList = [
      "\u{1F600}",
      "\u{1F603}",
      "\u{1F604}",
      "\u{1F601}",
      "\u{1F606}",
      "\u{1F605}",
      "\u{1F602}",
      "\u{1F923}",
      "\u{1F60A}",
      "\u{1F607}",
      "\u{1F642}",
      "\u{1F643}",
      "\u{1F609}",
      "\u{1F60C}",
      "\u{1F60D}",
      "\u{1F970}",
      "\u{1F618}",
      "\u{1F617}",
      "\u{1F619}",
      "\u{1F61A}",
      "\u{1F60B}",
      "\u{1F61C}",
      "\u{1F61D}",
      "\u{1F61B}",
      "\u{1F911}",
      "\u{1F917}",
      "\u{1F92D}",
      "\u{1F92B}",
      "\u{1F914}",
      "\u{1F910}",
      "\u{1F928}",
      "\u{1F610}",
      "\u{1F611}",
      "\u{1F636}",
      "\u{1F60F}",
      "\u{1F612}",
      "\u{1F644}",
      "\u{1F62C}",
      "\u{1F925}",
      "\u{1F614}",
      "\u{1F62A}",
      "\u{1F924}",
      "\u{1F634}",
      "\u{1F637}",
      "\u{1F912}",
      "\u{1F915}",
      "\u{1F922}",
      "\u{1F92E}",
      "\u{1F927}",
      "\u{1F975}",
      "\u{1F976}",
      "\u{1F974}",
      "\u{1F635}",
      "\u{1F92F}",
      "\u{1F920}",
      "\u{1F973}",
      "\u{1F60E}",
      "\u{1F913}",
      "\u{1F9D0}",
      "\u{1F615}",
      "\u{1F61F}",
      "\u{1F641}",
      "\u2639\uFE0F",
      "\u{1F62E}",
      "\u{1F62F}",
      "\u{1F632}",
      "\u{1F633}",
      "\u{1F97A}",
      "\u{1F626}",
      "\u{1F627}",
      "\u{1F628}",
      "\u{1F630}",
      "\u{1F625}",
      "\u{1F622}",
      "\u{1F62D}",
      "\u{1F631}",
      "\u{1F616}",
      "\u{1F623}",
      "\u{1F61E}",
      "\u{1F613}",
      "\u{1F629}",
      "\u{1F62B}",
      "\u{1F971}",
      "\u{1F624}",
      "\u{1F621}",
      "\u{1F620}",
      "\u{1F92C}",
      "\u{1F608}",
      "\u{1F47F}",
      "\u{1F480}",
      "\u2620\uFE0F",
      "\u{1F921}",
      "\u{1F479}",
      "\u{1F47A}",
      "\u{1F47B}",
      "\u{1F47D}",
      "\u{1F47E}",
      "\u{1F916}",
      "\u{1F63A}",
      "\u{1F638}",
      "\u{1F639}",
      "\u{1F63B}",
      "\u{1F63C}",
      "\u{1F63D}",
      "\u{1F640}",
      "\u{1F63F}",
      "\u{1F63E}",
      "\u{1F44D}",
      "\u{1F44E}",
      "\u{1F44F}",
      "\u{1F64C}",
      "\u{1F450}",
      "\u{1F91D}",
      "\u{1F44A}",
      "\u270A",
      "\u{1F91B}",
      "\u{1F91C}",
      "\u{1F44C}",
      "\u{1F90C}",
      "\u{1F90F}",
      "\u270C\uFE0F",
      "\u{1F91E}",
      "\u{1F91F}",
      "\u{1F918}",
      "\u{1F44C}",
      "\u{1F590}\uFE0F",
      "\u270B",
      "\u{1F91A}",
      "\u{1F44B}",
      "\u{1F919}",
      "\u{1F4AA}",
      "\u{1F9BE}",
      "\u{1F9E0}",
      "\u{1F9B4}",
      "\u{1F9B7}",
      "\u{1F440}",
      "\u{1F441}\uFE0F",
      "\u{1F445}",
      "\u{1F444}",
      "\u{1FAF6}",
      "\u{1FAF0}",
      "\u{1F64F}",
      "\u{1F485}",
      "\u{1F933}",
      "\u{1F525}",
      "\u2728",
      "\u{1F31F}",
      "\u{1F4AB}",
      "\u26A1",
      "\u{1F4A5}",
      "\u{1F4AF}",
      "\u{1F48E}",
      "\u{1F3AF}",
      "\u{1F3C6}",
      "\u{1F947}",
      "\u{1F948}",
      "\u{1F949}",
      "\u{1F396}\uFE0F",
      "\u{1F3C5}",
      "\u{1F4CC}",
      "\u{1F4CD}",
      "\u{1F9ED}",
      "\u{1F5FA}\uFE0F",
      "\u{1F3D4}\uFE0F",
      "\u{1F3D5}\uFE0F",
      "\u{1F3D6}\uFE0F",
      "\u{1F3DC}\uFE0F",
      "\u{1F3DD}\uFE0F",
      "\u{1F3DE}\uFE0F",
      "\u{1F30B}",
      "\u{1F5FB}",
      "\u{1F308}",
      "\u2600\uFE0F",
      "\u{1F324}\uFE0F",
      "\u26C5",
      "\u{1F325}\uFE0F",
      "\u{1F326}\uFE0F",
      "\u{1F327}\uFE0F",
      "\u26C8\uFE0F",
      "\u{1F329}\uFE0F",
      "\u2744\uFE0F",
      "\u{1F32A}\uFE0F",
      "\u{1F32B}\uFE0F",
      "\u{1F4A8}",
      "\u{1F4A7}",
      "\u{1F30A}",
      "\u{1F338}",
      "\u{1F33A}",
      "\u{1F33C}",
      "\u{1F33B}",
      "\u{1F337}",
      "\u{1F339}",
      "\u{1F33F}",
      "\u2618\uFE0F",
      "\u{1F340}",
      "\u{1F332}",
      "\u{1F333}",
      "\u{1F335}",
      "\u{1F38B}",
      "\u{1F334}",
      "\u{1F341}",
      "\u{1F342}",
      "\u{1F34E}",
      "\u{1F34C}",
      "\u{1F349}",
      "\u{1F347}",
      "\u{1F353}",
      "\u{1FAD0}",
      "\u{1F34D}",
      "\u{1F96D}",
      "\u{1F95D}",
      "\u{1F351}",
      "\u{1F352}",
      "\u{1F34B}",
      "\u{1F34A}",
      "\u{1F348}",
      "\u{1F965}",
      "\u{1F951}",
      "\u{1F966}",
      "\u{1F955}",
      "\u{1F33D}",
      "\u{1F355}",
      "\u{1F354}",
      "\u{1F35F}",
      "\u{1F32D}",
      "\u{1F37F}",
      "\u{1F96A}",
      "\u{1F32E}",
      "\u{1F32F}",
      "\u{1F957}",
      "\u{1F35D}",
      "\u{1F35C}",
      "\u{1F363}",
      "\u{1F371}",
      "\u{1F35B}",
      "\u{1F370}",
      "\u{1F9C1}",
      "\u{1F36A}",
      "\u{1F369}",
      "\u{1F366}",
      "\u{1F36B}",
      "\u2699\uFE0F",
      "\u{1F9E9}",
      "\u{1F9EA}",
      "\u{1F9EC}",
      "\u{1F52C}",
      "\u{1F52D}",
      "\u{1F4A1}",
      "\u{1F526}",
      "\u{1F56F}\uFE0F",
      "\u{1F4D6}",
      "\u{1F4DA}",
      "\u{1F4C2}",
      "\u{1F4C1}",
      "\u{1F4C4}",
      "\u{1F4DD}",
      "\u270F\uFE0F",
      "\u{1F58A}\uFE0F",
      "\u{1F58B}\uFE0F",
      "\u{1F9F7}",
      "\u{1F4CE}",
      "\u{1F5C2}\uFE0F",
      "\u{1F4CA}",
      "\u{1F4C8}",
      "\u{1F4C9}",
      "\u{1F4C5}",
      "\u{1F4C6}",
      "\u23F0",
      "\u23F1\uFE0F",
      "\u23F2\uFE0F",
      "\u{1F570}\uFE0F",
      "\u231B",
      "\u23F3",
      "\u{1F3A7}",
      "\u{1F3B8}",
      "\u{1F3B9}",
      "\u{1F941}",
      "\u{1F3BA}",
      "\u{1F3B7}",
      "\u{1F3BB}",
      "\u{1F3BC}",
      "\u{1F3AC}",
      "\u{1F3AE}",
      "\u{1F579}\uFE0F",
      "\u{1F3B2}",
      "\u{1F680}",
      "\u{1F6F8}",
      "\u{1F6F0}\uFE0F",
      "\u2708\uFE0F",
      "\u{1F6EB}",
      "\u{1F6EC}",
      "\u{1F697}",
      "\u{1F695}",
      "\u{1F699}",
      "\u{1F68C}",
      "\u{1F68E}",
      "\u{1F693}",
      "\u{1F691}",
      "\u{1F692}",
      "\u{1F69A}",
      "\u{1F69B}",
      "\u{1F6B2}",
      "\u{1F6F4}",
      "\u{1F3CD}\uFE0F",
      "\u{1F3E0}",
      "\u{1F3E1}",
      "\u{1F3E2}",
      "\u{1F3EC}",
      "\u{1F3ED}",
      "\u{1F3F0}",
      "\u{1F3EF}",
      "\u{1F5FC}",
      "\u{1F5FD}",
      "\u26E9\uFE0F",
      "\u{1F54C}",
      "\u{1F54D}",
      "\u26EA",
      "\u{1F54B}",
      "\u2764\uFE0F",
      "\u{1F9E1}",
      "\u{1F49B}",
      "\u{1F49A}",
      "\u{1F499}",
      "\u{1F49C}",
      "\u{1F5A4}",
      "\u{1F90D}",
      "\u{1F90E}",
      "\u{1F496}",
      "\u{1F498}",
      "\u{1F49D}",
      "\u{1F48C}",
      "\u{1F495}",
      "\u{1F49E}",
      "\u{1F493}",
      "\u{1F497}",
      "\u{1F49F}"
    ];
    const emojiSetting = new import_obsidian.Setting(contentEl).setName(t("modal_emoji_label")).setDesc(t("modal_emoji_desc"));
    const emojiContainer = emojiSetting.controlEl.createDiv({ cls: "emoji-picker-container" });
    emojiGrid = emojiContainer.createDiv({ cls: "emoji-grid" });
    const renderEmojis = (filter) => {
      emojiGrid.empty();
      const folder = this.folder;
      emojiList.filter((e) => !filter || e.includes(filter)).forEach((e) => {
        const btn = emojiGrid.createEl("button", { text: e });
        btn.className = "emoji-btn";
        if (folder.emoji === e) btn.classList.add("selected");
        btn.onclick = () => {
          folder.emoji = e;
          folder.customIconPath = void 0;
          clearIconSelection();
          clearCustomIconSelection();
          Array.from(emojiGrid.children).forEach((child) => child.classList.remove("selected"));
          btn.classList.add("selected");
          if (!this.isNew) this.plugin.updateIconTypeInDom(this.folder.id, "emoji", e);
          if (!this.isNew) this.plugin.updateIconStyleInDom(this.folder.id, this.folder.customIconSize || 28, this.folder.customIconOffsetX || 0, this.folder.customIconOffsetY || 0);
        };
      });
    };
    renderEmojis("");
    const iconAdjustSetting = new import_obsidian.Setting(contentEl).setName("Icon Adjustments");
    iconAdjustSetting.settingEl.addClass("magic-custom-icon-setting");
    iconAdjustSetting.controlEl.addClass("magic-custom-icon-control");
    const iconAdjustWrap = iconAdjustSetting.controlEl.createDiv({ cls: "magic-custom-icon-wrap" });
    const adjustRow = iconAdjustWrap.createDiv({ cls: "magic-custom-icon-preview-row" });
    const sizeWrap = adjustRow.createDiv({ cls: "magic-custom-icon-size" });
    sizeWrap.createSpan({ text: "Size:" });
    customIconSlider = sizeWrap.createEl("input", { type: "range", min: "10", max: "64", step: "2" });
    const currentSize = (_a = this.folder.customIconSize) != null ? _a : 28;
    customIconSlider.value = String(currentSize);
    customIconSizeValue = sizeWrap.createEl("span", { text: `${currentSize}px` });
    const offsetContainer = iconAdjustWrap.createDiv();
    offsetContainer.style.display = "flex";
    offsetContainer.style.gap = "10px";
    offsetContainer.style.marginTop = "8px";
    const yWrap = offsetContainer.createDiv({ cls: "magic-custom-icon-offset" });
    yWrap.createSpan({ text: "Y:" });
    const yInput = yWrap.createEl("input", { type: "range", min: "-20", max: "20", step: "1" });
    const currentY = (_b = this.folder.customIconOffsetY) != null ? _b : 0;
    yInput.value = String(currentY);
    const yValue = yWrap.createEl("span", { text: `${currentY}` });
    const xWrap = offsetContainer.createDiv({ cls: "magic-custom-icon-offset" });
    xWrap.createSpan({ text: "X:" });
    const xInput = xWrap.createEl("input", { type: "range", min: "-20", max: "20", step: "1" });
    const currentX = (_c = this.folder.customIconOffsetX) != null ? _c : 0;
    xInput.value = String(currentX);
    const xValue = xWrap.createEl("span", { text: `${currentX}` });
    const updateStyles = () => {
      const s = Number(customIconSlider.value);
      const x = Number(xInput.value);
      const y = Number(yInput.value);
      this.folder.customIconSize = s;
      this.folder.customIconOffsetX = x;
      this.folder.customIconOffsetY = y;
      customIconSizeValue.textContent = `${s}px`;
      xValue.textContent = String(x);
      yValue.textContent = String(y);
      if (!this.isNew) {
        const liveFolder = this.plugin.settings.magicFolders.find((f) => f.id === this.folder.id);
        if (liveFolder) {
          liveFolder.customIconSize = s;
          liveFolder.customIconOffsetX = x;
          liveFolder.customIconOffsetY = y;
        }
        this.plugin.updateIconStyleInDom(this.folder.id, s, x, y);
      }
      if (customIconPreview) {
        customIconPreview.style.width = this.folder.customIconKeepRatio ? "auto" : `${s}px`;
        customIconPreview.style.height = `${s}px`;
        customIconPreview.style.transform = `translate(${x}px, ${y}px)`;
      }
    };
    customIconSlider.addEventListener("input", updateStyles);
    xInput.addEventListener("input", updateStyles);
    yInput.addEventListener("input", updateStyles);
    const applyCustomIcon = async (sourcePath) => {
      const size = this.folder.customIconSize || 28;
      const saved = await this.plugin.saveCustomIconForFolder(this.folder.id, sourcePath, size, !!this.folder.customIconKeepRatio);
      if (!saved) return;
      this.folder.customIconSourcePath = sourcePath;
      this.folder.customIconPath = saved.filePath;
      this.folder.emoji = void 0;
      clearIconSelection();
      clearCustomIconSelection();
      if (emojiGrid) emojiGrid.querySelectorAll(".emoji-btn").forEach((b) => b.classList.remove("selected"));
      if (customIconPreview) {
        customIconPreview.src = saved.previewDataUrl;
        customIconPreview.style.width = this.folder.customIconKeepRatio ? "auto" : `${size}px`;
        customIconPreview.style.height = `${size}px`;
        const offsetX = this.folder.customIconOffsetX || 0;
        const offsetY = this.folder.customIconOffsetY || 0;
        customIconPreview.style.transform = offsetX !== 0 || offsetY !== 0 ? `translate(${offsetX}px, ${offsetY}px)` : "";
      }
      if (!this.isNew) {
        const liveFolder = this.plugin.settings.magicFolders.find((f) => f.id === this.folder.id);
        if (liveFolder) {
          liveFolder.customIconSourcePath = sourcePath;
          liveFolder.customIconPath = saved.filePath;
          liveFolder.customIconSize = size;
          liveFolder.customIconKeepRatio = !!this.folder.customIconKeepRatio;
        }
      }
      this.plugin.updateCustomIconInDom(this.folder.id, saved.previewDataUrl);
      this.plugin.updateCustomIconSizeInDom(this.folder.id, size);
    };
    if (this.plugin.settings.customIconsEnabled && this.plugin.settings.customIconFolder) {
      const customIconSetting = new import_obsidian.Setting(contentEl).setName(t("modal_custom_icons_label"));
      customIconSetting.settingEl.addClass("magic-custom-icon-setting");
      customIconSetting.controlEl.addClass("magic-custom-icon-control");
      const customIconWrap = customIconSetting.controlEl.createDiv({ cls: "magic-custom-icon-wrap" });
      const ratioRow = customIconWrap.createDiv({ cls: "magic-custom-icon-preview-row" });
      const ratioWrap = ratioRow.createDiv({ cls: "magic-custom-icon-ratio" });
      const ratioCheckbox = ratioWrap.createEl("input", { type: "checkbox" });
      ratioCheckbox.checked = !!this.folder.customIconKeepRatio;
      ratioWrap.createEl("span", { text: "Keep Image Ratio" });
      ratioCheckbox.addEventListener("change", () => {
        this.folder.customIconKeepRatio = ratioCheckbox.checked;
        if (!this.isNew) {
          const liveFolder = this.plugin.settings.magicFolders.find((f) => f.id === this.folder.id);
          if (liveFolder) liveFolder.customIconKeepRatio = ratioCheckbox.checked;
        }
        updateStyles();
      });
      customIconContainer = customIconWrap.createDiv("custom-icon-grid");
      const previewRow = customIconWrap.createDiv({ cls: "magic-custom-icon-preview-row" });
      customIconPreview = previewRow.createEl("img", { cls: "magic-folder-custom-icon" });
      customIconPreview.style.display = "none";
      if (this.folder.customIconSourcePath || this.folder.customIconPath) {
        customIconPreview.style.display = "inline-block";
        const path2 = this.folder.customIconSourcePath || this.folder.customIconPath;
        this.plugin.loadIconIntoImg(path2, customIconPreview);
        customIconPreview.style.height = `${currentSize}px`;
        customIconPreview.style.width = this.folder.customIconKeepRatio ? "auto" : `${currentSize}px`;
        customIconPreview.style.transform = `translate(${currentX}px, ${currentY}px)`;
      }
      const allowed = /* @__PURE__ */ new Set(["svg", "png", "jpg", "jpeg", "gif", "webp"]);
      const iconFolderPath = this.plugin.settings.customIconFolder.trim();
      if (this.plugin.isExternalPath(iconFolderPath)) {
        try {
          const entries = fs.readdirSync(iconFolderPath, { withFileTypes: true });
          for (const entry of entries) {
            if (!entry.isFile()) continue;
            const ext = path.extname(entry.name).replace(".", "").toLowerCase();
            if (!allowed.has(ext)) continue;
            const filePath = path.join(iconFolderPath, entry.name);
            const btn = customIconContainer.createEl("button", { cls: "custom-icon-btn" });
            const img = btn.createEl("img");
            img.className = "magic-folder-custom-icon";
            img.classList.add("is-loading");
            img.loading = "lazy";
            img.decoding = "async";
            this.plugin.loadIconIntoImg(filePath, img);
            if (this.folder.customIconSourcePath === filePath) {
              btn.classList.add("selected");
            }
            btn.addEventListener("click", () => {
              btn.classList.add("selected");
              customIconPreview.style.display = "inline-block";
              void applyCustomIcon(filePath);
            });
          }
        } catch (err) {
        }
      } else {
        const folder = this.plugin.app.vault.getAbstractFileByPath(iconFolderPath);
        if (folder instanceof import_obsidian.TFolder) {
          const files = folder.children.filter((child) => child instanceof import_obsidian.TFile && allowed.has(child.extension.toLowerCase()));
          for (const file of files) {
            const btn = customIconContainer.createEl("button", { cls: "custom-icon-btn" });
            const img = btn.createEl("img");
            img.className = "magic-folder-custom-icon";
            img.classList.add("is-loading");
            img.loading = "lazy";
            img.decoding = "async";
            this.plugin.loadIconIntoImg(file.path, img);
            if (this.folder.customIconSourcePath === file.path) {
              btn.classList.add("selected");
            }
            btn.addEventListener("click", () => {
              btn.classList.add("selected");
              customIconPreview.style.display = "inline-block";
              void applyCustomIcon(file.path);
            });
          }
        }
      }
    }
    new import_obsidian.Setting(contentEl).setName(t("modal_sort_by_label")).setDesc(t("modal_sort_by_desc")).addDropdown((dropdown) => {
      dropdown.addOption("name", t("modal_sort_name")).addOption("modified", t("modal_sort_modified")).addOption("created", t("modal_sort_created")).addOption("type", t("modal_sort_type")).addOption("size", t("modal_sort_size")).addOption("tag", t("modal_sort_tag")).setValue(this.folder.sortBy).onChange((value) => {
        this.folder.sortBy = value;
      });
    }).addDropdown((dropdown) => {
      dropdown.addOption("asc", t("modal_sort_asc")).addOption("desc", t("modal_sort_desc")).setValue(this.folder.sortOrder).onChange((value) => {
        this.folder.sortOrder = value;
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonContainer.createEl("button", { text: t("modal_cancel") });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", {
      text: this.isNew ? t("modal_create") : t("modal_save"),
      cls: "mod-cta"
    });
    saveBtn.addEventListener("click", async () => {
      if (!this.folder.name.trim()) {
        new import_obsidian.Notice(this.plugin.t("notice_name_required"));
        return;
      }
      if (this.isNew) {
        await this.plugin.createMagicFolder(this.folder);
      } else {
        await this.plugin.updateMagicFolder(this.folder);
      }
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    document.body.classList.remove("magic-folder-edit-modal-open");
    for (const cleanup of this.domEventCleanup) cleanup();
    this.domEventCleanup = [];
  }
};
var DoMagicModal = class extends import_obsidian.Modal {
  constructor(app, plugin, folder) {
    super(app);
    this.filterInput = null;
    this.filtersContainer = null;
    this.previewContainer = null;
    this.suggestionsContainer = null;
    this.allTags = [];
    this.allLinks = [];
    this.selectedSuggestionIndex = -1;
    this.currentLogic = "OR";
    this.domEventCleanup = [];
    this.plugin = plugin;
    this.folder = { ...folder, filters: [...folder.filters] };
    this.loadAllTagsAndLinks();
  }
  addDomEvent(el, type, handler, options) {
    el.addEventListener(type, handler, options);
    this.domEventCleanup.push(() => {
      el.removeEventListener(type, handler, options);
    });
  }
  loadAllTagsAndLinks() {
    var _a;
    const tagSet = /* @__PURE__ */ new Set();
    const linkSet = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (!cache) continue;
      if (cache.tags) {
        for (const tag of cache.tags) {
          tagSet.add(tag.tag);
        }
      }
      if ((_a = cache.frontmatter) == null ? void 0 : _a.tags) {
        const fmTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
        for (const tag of fmTags) {
          tagSet.add("#" + String(tag).replace(/^#/, ""));
        }
      }
      if (cache.links) {
        for (const link of cache.links) {
          linkSet.add(link.link);
        }
      }
      linkSet.add(file.basename);
    }
    this.allTags = Array.from(tagSet).sort();
    this.allLinks = Array.from(linkSet).sort();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("magic-folder-modal");
    this.modalEl.addClass("magic-folder-modal");
    const t = this.plugin.t.bind(this.plugin);
    const titleEl = contentEl.createEl("h2");
    titleEl.createSpan({ text: t("do_magic_title") });
    const folderName = (this.folder.name || "").trim();
    if (folderName) {
      const contextEl = titleEl.createSpan({ cls: "magic-do-title-context" });
      contextEl.style.marginLeft = "8px";
      contextEl.style.color = this.folder.color || "var(--text-muted)";
      const iconEl = contextEl.createSpan({ cls: "magic-do-title-icon" });
      iconEl.style.display = "inline-flex";
      iconEl.style.alignItems = "center";
      iconEl.style.justifyContent = "center";
      iconEl.style.verticalAlign = "middle";
      if (this.folder.customIconPath) {
        const resourcePath = this.plugin.getCustomIconResource(this.folder.customIconPath);
        if (resourcePath) {
          const img = iconEl.createEl("img");
          img.src = resourcePath;
          img.className = "magic-folder-custom-icon";
          img.style.width = "16px";
          img.style.height = "16px";
        }
      }
      if (iconEl.childElementCount === 0) {
        if (this.folder.emoji) {
          iconEl.textContent = this.folder.emoji;
        } else {
          (0, import_obsidian.setIcon)(iconEl, this.folder.icon || "folder");
          const svg = iconEl.querySelector("svg");
          if (svg) {
            svg.style.width = "16px";
            svg.style.height = "16px";
          }
        }
      }
      contextEl.createSpan({ text: ` ${folderName}` });
    }
    const helpRow = contentEl.createDiv("magic-help-row");
    helpRow.createDiv({
      text: t("do_magic_help"),
      cls: "magic-help-text"
    });
    const helpWrap = helpRow.createDiv("magic-help-wrap");
    const helpBtn = helpWrap.createEl("button", { cls: "magic-help-btn", attr: { "aria-label": "Help" } });
    helpBtn.textContent = "i";
    const helpTooltip = helpWrap.createDiv("magic-help-tooltip");
    const helpLines = [
      t("do_magic_help_tags"),
      t("do_magic_help_links"),
      t("do_magic_help_folder"),
      t("do_magic_help_ext"),
      t("do_magic_help_frontmatter"),
      t("do_magic_help_multi"),
      t("do_magic_help_logic")
    ];
    for (const line of helpLines) {
      helpTooltip.createDiv({ text: line });
    }
    const closeHelp = () => helpWrap.removeClass("is-open");
    this.addDomEvent(helpBtn, "click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      helpWrap.toggleClass("is-open");
    });
    this.addDomEvent(helpWrap, "mouseenter", () => helpWrap.addClass("is-open"));
    this.addDomEvent(helpWrap, "mouseleave", closeHelp);
    this.addDomEvent(helpBtn, "blur", closeHelp);
    this.filtersContainer = contentEl.createDiv("filters-container");
    this.renderFilters();
    const logicContainer = contentEl.createDiv("logic-selector-container");
    logicContainer.style.cssText = `
			display: flex;
			gap: 8px;
			margin: 12px 0;
			align-items: center;
		`;
    logicContainer.createSpan({ text: t("do_magic_logic_label"), cls: "setting-item-description" });
    const logicOptions = ["OR", "AND", "NOT"];
    const logicButtons = /* @__PURE__ */ new Map();
    for (const logic of logicOptions) {
      const btn = logicContainer.createEl("button", { text: logic });
      btn.addClass("logic-btn");
      if (logic === this.currentLogic) {
        btn.addClass("logic-btn-active");
      }
      const colors = {
        "OR": "#2ecc71",
        "AND": "#3498db",
        "NOT": "#e74c3c"
      };
      btn.style.cssText = `
				padding: 4px 12px;
				border-radius: 4px;
				border: 2px solid ${logic === this.currentLogic ? colors[logic] : "var(--background-modifier-border)"};
				background: ${logic === this.currentLogic ? colors[logic] + "22" : "transparent"};
				color: ${logic === this.currentLogic ? colors[logic] : "var(--text-muted)"};
				font-weight: 600;
				cursor: pointer;
				transition: all 0.15s ease;
			`;
      btn.addEventListener("click", () => {
        this.currentLogic = logic;
        for (const [l, b] of logicButtons) {
          const isActive = l === logic;
          b.style.borderColor = isActive ? colors[l] : "var(--background-modifier-border)";
          b.style.background = isActive ? colors[l] + "22" : "transparent";
          b.style.color = isActive ? colors[l] : "var(--text-muted)";
          if (isActive) b.addClass("logic-btn-active");
          else b.removeClass("logic-btn-active");
        }
      });
      logicButtons.set(logic, btn);
    }
    const inputWrapper = contentEl.createDiv("filter-input-wrapper");
    inputWrapper.style.position = "relative";
    const inputContainer = inputWrapper.createDiv("filter-input-container");
    this.filterInput = inputContainer.createEl("input", {
      type: "text",
      placeholder: t("do_magic_input_placeholder")
    });
    const addBtn = inputContainer.createEl("button", { text: t("do_magic_add"), cls: "mod-cta" });
    addBtn.addEventListener("click", () => this.addFilterFromInput());
    const quickInsert = contentEl.createDiv("magic-quick-insert");
    const insertToInput = (value) => {
      if (!this.filterInput) return;
      this.filterInput.value = value;
      this.filterInput.focus();
    };
    const quickItems = [
      { label: "#tag", value: "#ChangeMe" },
      { label: "[[link]]", value: "[[ModifyHere]]" },
      { label: "folder:", value: "folder:Folder/Sub" },
      { label: ".ext", value: ".pdf" },
      { label: "ext:", value: "ext:pdf" },
      { label: "key:value", value: "key:value" }
    ];
    for (const item of quickItems) {
      const btn = quickInsert.createEl("button", { text: item.label, cls: "magic-quick-btn" });
      this.addDomEvent(btn, "click", (ev) => {
        ev.preventDefault();
        insertToInput(item.value);
      });
    }
    this.suggestionsContainer = inputWrapper.createDiv("magic-suggestions");
    this.suggestionsContainer.style.cssText = `
			position: absolute;
			top: 100%;
			left: 0;
			right: 0;
			max-height: 200px;
			overflow-y: auto;
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 6px;
			z-index: 1000;
			display: none;
			box-shadow: 0 4px 12px rgba(0,0,0,0.15);
		`;
    this.filterInput.addEventListener("input", () => this.onInputChange());
    this.filterInput.addEventListener("keydown", (e) => this.onInputKeydown(e));
    this.filterInput.addEventListener("blur", () => {
      setTimeout(() => this.hideSuggestions(), 150);
    });
    this.filterInput.addEventListener("focus", () => this.onInputChange());
    contentEl.createEl("h3", { text: t("do_magic_preview"), cls: "setting-item-name" });
    this.previewContainer = contentEl.createDiv();
    this.previewContainer.style.maxHeight = "200px";
    this.previewContainer.style.overflow = "auto";
    this.previewContainer.style.background = "var(--background-secondary)";
    this.previewContainer.style.padding = "8px";
    this.previewContainer.style.borderRadius = "4px";
    this.updatePreview();
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.marginTop = "16px";
    const cancelBtn = buttonContainer.createEl("button", { text: t("modal_cancel") });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", { text: t("do_magic_apply"), cls: "mod-cta" });
    saveBtn.addEventListener("click", async () => {
      await this.plugin.updateMagicFolder(this.folder);
      this.close();
    });
  }
  onInputChange() {
    if (!this.filterInput || !this.suggestionsContainer) return;
    const value = this.filterInput.value;
    const suggestions = [];
    if (value.startsWith("#")) {
      const search = value.toLowerCase();
      for (const tag of this.allTags) {
        if (tag.toLowerCase().includes(search) || tag.toLowerCase().startsWith(search.slice(1))) {
          suggestions.push({ text: tag, type: "tag" });
          if (suggestions.length >= 15) break;
        }
      }
    } else if (value.startsWith("[[") || value.startsWith("[")) {
      const search = value.replace(/^\[+/, "").replace(/\]+$/, "").toLowerCase();
      for (const link of this.allLinks) {
        if (link.toLowerCase().includes(search)) {
          suggestions.push({ text: `[[${link}]]`, type: "link" });
          if (suggestions.length >= 15) break;
        }
      }
    } else if (value.startsWith(".")) {
      const commonExts = ["pdf", "png", "jpg", "jpeg", "gif", "svg", "mp3", "mp4", "wav", "fbx", "obj", "glb", "gltf", "blend", "psd", "ai", "zip", "rar", "doc", "docx", "xls", "xlsx", "ppt", "pptx", "txt", "csv", "json", "xml", "html", "css", "js", "ts", "py", "md"];
      const search = value.slice(1).toLowerCase();
      for (const ext of commonExts) {
        if (ext.startsWith(search) || ext.includes(search)) {
          suggestions.push({ text: "." + ext, type: "extension" });
          if (suggestions.length >= 15) break;
        }
      }
    } else if (value.length > 0) {
      const search = value.toLowerCase();
      for (const tag of this.allTags) {
        if (tag.toLowerCase().includes(search)) {
          suggestions.push({ text: tag, type: "tag" });
          if (suggestions.length >= 8) break;
        }
      }
      for (const link of this.allLinks) {
        if (link.toLowerCase().includes(search)) {
          suggestions.push({ text: `[[${link}]]`, type: "link" });
          if (suggestions.length >= 15) break;
        }
      }
    }
    this.renderSuggestions(suggestions);
  }
  renderSuggestions(suggestions) {
    if (!this.suggestionsContainer) return;
    this.suggestionsContainer.empty();
    this.selectedSuggestionIndex = -1;
    if (suggestions.length === 0) {
      this.suggestionsContainer.style.display = "none";
      return;
    }
    this.suggestionsContainer.style.display = "block";
    for (let i = 0; i < suggestions.length; i++) {
      const suggestion = suggestions[i];
      const item = this.suggestionsContainer.createDiv("magic-suggestion-item");
      item.dataset.index = String(i);
      item.style.cssText = `
				padding: 8px 12px;
				cursor: pointer;
				display: flex;
				align-items: center;
				gap: 8px;
				border-bottom: 1px solid var(--background-modifier-border);
			`;
      const icon = item.createSpan();
      icon.style.opacity = "0.7";
      switch (suggestion.type) {
        case "tag":
          (0, import_obsidian.setIcon)(icon, "hash");
          item.style.color = "var(--text-accent)";
          break;
        case "link":
          (0, import_obsidian.setIcon)(icon, "link");
          item.style.color = "var(--text-accent-hover)";
          break;
        case "extension":
          (0, import_obsidian.setIcon)(icon, "file");
          item.style.color = "var(--text-muted)";
          break;
      }
      item.createSpan({ text: suggestion.text });
      item.addEventListener("mouseenter", () => {
        var _a;
        (_a = this.suggestionsContainer) == null ? void 0 : _a.querySelectorAll(".magic-suggestion-item").forEach((el) => {
          el.style.background = "";
        });
        item.style.background = "var(--background-modifier-hover)";
        this.selectedSuggestionIndex = i;
      });
      item.addEventListener("mouseleave", () => {
        item.style.background = "";
      });
      item.addEventListener("click", () => {
        this.selectSuggestion(suggestion);
      });
    }
  }
  selectSuggestion(suggestion) {
    let filter;
    switch (suggestion.type) {
      case "tag":
        filter = { type: "tag", value: suggestion.text, operator: "contains", logic: this.currentLogic };
        break;
      case "link":
        filter = { type: "link", value: suggestion.text.slice(2, -2), operator: "contains", logic: this.currentLogic };
        break;
      case "extension":
        filter = { type: "extension", value: suggestion.text.slice(1), operator: "equals", logic: this.currentLogic };
        break;
    }
    this.addFilter(filter);
    if (this.filterInput) {
      this.filterInput.value = "";
      this.filterInput.focus();
    }
    this.hideSuggestions();
  }
  onInputKeydown(e) {
    if (!this.suggestionsContainer) return;
    const items = this.suggestionsContainer.querySelectorAll(".magic-suggestion-item");
    if (e.key === "ArrowDown") {
      e.preventDefault();
      this.selectedSuggestionIndex = Math.min(this.selectedSuggestionIndex + 1, items.length - 1);
      this.highlightSuggestion(items);
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      this.selectedSuggestionIndex = Math.max(this.selectedSuggestionIndex - 1, 0);
      this.highlightSuggestion(items);
    } else if (e.key === "Enter") {
      if (this.selectedSuggestionIndex >= 0 && items[this.selectedSuggestionIndex]) {
        e.preventDefault();
        items[this.selectedSuggestionIndex].click();
      } else {
        this.addFilterFromInput();
      }
    } else if (e.key === "Escape") {
      this.hideSuggestions();
    }
  }
  highlightSuggestion(items) {
    items.forEach((item, index) => {
      item.style.background = index === this.selectedSuggestionIndex ? "var(--background-modifier-hover)" : "";
    });
    if (items[this.selectedSuggestionIndex]) {
      items[this.selectedSuggestionIndex].scrollIntoView({ block: "nearest" });
    }
  }
  hideSuggestions() {
    if (this.suggestionsContainer) {
      this.suggestionsContainer.style.display = "none";
    }
    this.selectedSuggestionIndex = -1;
  }
  addFilterFromInput() {
    if (!this.filterInput) return;
    const value = this.filterInput.value.trim();
    if (!value) return;
    const filters = this.parseFilterInput(value);
    for (const filter of filters) {
      this.addFilter(filter);
    }
    this.filterInput.value = "";
  }
  parseFilterInput(input) {
    const filters = [];
    const parts = input.split(/\s+/);
    for (const part of parts) {
      if (part.startsWith("#")) {
        filters.push({ type: "tag", value: part, operator: "contains", logic: this.currentLogic });
      } else if (part.startsWith("[[") && part.endsWith("]]")) {
        filters.push({ type: "link", value: part.slice(2, -2), operator: "contains", logic: this.currentLogic });
      } else if (part.startsWith("folder:")) {
        filters.push({ type: "folder", value: part.slice(7), operator: "contains", logic: this.currentLogic });
      } else if (part.startsWith("ext:")) {
        filters.push({ type: "extension", value: part.slice(4).replace(/^\./, ""), operator: "equals", logic: this.currentLogic });
      } else if (part.startsWith(".") && part.length > 1 && !part.includes(" ")) {
        filters.push({ type: "extension", value: part.slice(1), operator: "equals", logic: this.currentLogic });
      } else if (part.includes(":")) {
        filters.push({ type: "frontmatter", value: part, operator: "contains", logic: this.currentLogic });
      } else if (part.length > 0) {
        filters.push({ type: "tag", value: "#" + part, operator: "contains", logic: this.currentLogic });
      }
    }
    return filters;
  }
  addFilter(filter) {
    const exists = this.folder.filters.some(
      (f) => f.type === filter.type && f.value === filter.value && f.logic === filter.logic
    );
    if (exists) {
      new import_obsidian.Notice("This filter already exists");
      return;
    }
    this.folder.filters.push(filter);
    this.renderFilters();
    this.updatePreview();
  }
  removeFilter(index) {
    this.folder.filters.splice(index, 1);
    this.renderFilters();
    this.updatePreview();
  }
  renderFilters() {
    if (!this.filtersContainer) return;
    this.filtersContainer.empty();
    if (this.folder.filters.length === 0) {
      this.filtersContainer.createEl("p", {
        text: "No filters yet. Add tags or links above!",
        cls: "setting-item-description"
      });
      return;
    }
    const logicGroups = {
      "OR": [],
      "AND": [],
      "NOT": []
    };
    for (const filter of this.folder.filters) {
      const logic = filter.logic || "OR";
      logicGroups[logic].push(filter);
    }
    const logicColors = {
      "OR": "#2ecc71",
      "AND": "#3498db",
      "NOT": "#e74c3c"
    };
    const logicLabels = {
      "OR": "Match ANY of:",
      "AND": "Must have ALL:",
      "NOT": "Exclude if has:"
    };
    for (const logic of ["OR", "AND", "NOT"]) {
      const filters = logicGroups[logic];
      if (filters.length === 0) continue;
      const groupEl = this.filtersContainer.createDiv("filter-logic-group");
      groupEl.style.cssText = `
				margin-bottom: 12px;
				padding: 8px;
				border-left: 3px solid ${logicColors[logic]};
				background: ${logicColors[logic]}11;
				border-radius: 0 6px 6px 0;
			`;
      const labelEl = groupEl.createDiv("filter-logic-label");
      labelEl.style.cssText = `
				font-size: 11px;
				font-weight: 600;
				color: ${logicColors[logic]};
				margin-bottom: 6px;
				text-transform: uppercase;
				letter-spacing: 0.5px;
			`;
      labelEl.textContent = logicLabels[logic];
      const tagsContainer = groupEl.createDiv("filter-tags");
      tagsContainer.style.cssText = "display: flex; flex-wrap: wrap; gap: 4px;";
      for (const filter of filters) {
        const filterIndex = this.folder.filters.indexOf(filter);
        const tagEl = tagsContainer.createDiv("filter-tag");
        tagEl.style.borderColor = logicColors[logic];
        const iconEl = tagEl.createSpan();
        let displayValue = filter.value;
        switch (filter.type) {
          case "tag":
            (0, import_obsidian.setIcon)(iconEl, "hash");
            break;
          case "link":
            (0, import_obsidian.setIcon)(iconEl, "link");
            break;
          case "folder":
            (0, import_obsidian.setIcon)(iconEl, "folder");
            break;
          case "extension":
            (0, import_obsidian.setIcon)(iconEl, "file");
            displayValue = "." + filter.value;
            break;
          case "frontmatter":
            (0, import_obsidian.setIcon)(iconEl, "list");
            break;
        }
        tagEl.createSpan({ text: displayValue });
        const removeEl = tagEl.createSpan({ text: "\xD7", cls: "remove-filter" });
        removeEl.addEventListener("click", () => this.removeFilter(filterIndex));
      }
    }
  }
  async updatePreview() {
    if (!this.previewContainer) return;
    const t = this.plugin.t.bind(this.plugin);
    this.previewContainer.empty();
    if (this.folder.filters.length === 0) {
      this.previewContainer.createEl("p", {
        text: t("do_magic_preview_empty"),
        cls: "setting-item-description"
      });
      return;
    }
    const files = await this.plugin.getMatchingFiles(this.folder);
    if (files.length === 0) {
      this.previewContainer.createEl("p", {
        text: t("do_magic_preview_none"),
        cls: "setting-item-description"
      });
      return;
    }
    const countEl = this.previewContainer.createEl("p");
    countEl.innerHTML = t("do_magic_preview_count", { count: files.length });
    const listEl = this.previewContainer.createEl("ul");
    listEl.style.marginTop = "8px";
    listEl.style.paddingLeft = "20px";
    const displayFiles = files.slice(0, 15);
    for (const file of displayFiles) {
      const li = listEl.createEl("li");
      li.textContent = file.basename;
      li.style.fontSize = "12px";
      li.style.color = "var(--text-muted)";
    }
    if (files.length > 15) {
      const moreEl = listEl.createEl("li");
      moreEl.textContent = `... and ${files.length - 15} more`;
      moreEl.style.fontStyle = "italic";
      moreEl.style.color = "var(--text-faint)";
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
